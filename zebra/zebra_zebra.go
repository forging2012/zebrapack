// Code generated by ZEBRAPACK (github.com/glycerine/zebrapack). DO NOT EDIT.

package zebra

import (
	"github.com/glycerine/zebrapack/msgp"
)

// ZebraDecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Field) ZebraDecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields0zxcj = 11

	// -- templateDecodeMsgZid starts here--
	var totalEncodedFields0zxcj uint32
	totalEncodedFields0zxcj, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft0zxcj := totalEncodedFields0zxcj
	missingFieldsLeft0zxcj := maxFields0zxcj - totalEncodedFields0zxcj

	var nextMiss0zxcj int = -1
	var found0zxcj [maxFields0zxcj]bool
	var curField0zxcj int

doneWithStruct0zxcj:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft0zxcj > 0 || missingFieldsLeft0zxcj > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft0zxcj, missingFieldsLeft0zxcj, msgp.ShowFound(found0zxcj[:]), decodeMsgFieldOrder0zxcj)
		if encodedFieldsLeft0zxcj > 0 {
			encodedFieldsLeft0zxcj--
			curField0zxcj, err = dc.ReadInt()
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss0zxcj < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss0zxcj = 0
			}
			for nextMiss0zxcj < maxFields0zxcj && (found0zxcj[nextMiss0zxcj] || decodeMsgFieldSkip0zxcj[nextMiss0zxcj]) {
				nextMiss0zxcj++
			}
			if nextMiss0zxcj == maxFields0zxcj {
				// filled all the empty fields!
				break doneWithStruct0zxcj
			}
			missingFieldsLeft0zxcj--
			curField0zxcj = nextMiss0zxcj
		}
		//fmt.Printf("switching on curField: '%v'\n", curField0zxcj)
		switch curField0zxcj {
		// -- templateDecodeMsgZid ends here --

		case 0:
			// zid 0 for "Zid"
			found0zxcj[0] = true
			z.Zid, err = dc.ReadInt64()
			if err != nil {
				return
			}
		case 1:
			// zid 1 for "FieldGoName"
			found0zxcj[1] = true
			z.FieldGoName, err = dc.ReadString()
			if err != nil {
				return
			}
		case 2:
			// zid 2 for "FieldTagName"
			found0zxcj[2] = true
			z.FieldTagName, err = dc.ReadString()
			if err != nil {
				return
			}
		case 3:
			// zid 3 for "FieldTypeStr"
			found0zxcj[3] = true
			z.FieldTypeStr, err = dc.ReadString()
			if err != nil {
				return
			}
		case 4:
			// zid 4 for "FieldCategory"
			found0zxcj[4] = true
			{
				var zpue uint64
				zpue, err = dc.ReadUint64()
				z.FieldCategory = Zkind(zpue)
			}
			if err != nil {
				return
			}
		case 5:
			// zid 5 for "FieldPrimitive"
			found0zxcj[5] = true
			{
				var zfjt uint64
				zfjt, err = dc.ReadUint64()
				z.FieldPrimitive = Zkind(zfjt)
			}
			if err != nil {
				return
			}
		case 6:
			// zid 6 for "FieldFullType"
			found0zxcj[6] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.FieldFullType != nil {
					dc.PushAlwaysNil()
					err = z.FieldFullType.ZebraDecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.FieldFullType == nil {
					z.FieldFullType = new(Ztype)
				}
				err = z.FieldFullType.ZebraDecodeMsg(dc)
				if err != nil {
					return
				}
			}
		case 7:
			// zid 7 for "OmitEmpty"
			found0zxcj[7] = true
			z.OmitEmpty, err = dc.ReadBool()
			if err != nil {
				return
			}
		case 8:
			// zid 8 for "Skip"
			found0zxcj[8] = true
			z.Skip, err = dc.ReadBool()
			if err != nil {
				return
			}
		case 9:
			// zid 9 for "Deprecated"
			found0zxcj[9] = true
			z.Deprecated, err = dc.ReadBool()
			if err != nil {
				return
			}
		case 10:
			// zid 10 for "ShowZero"
			found0zxcj[10] = true
			z.ShowZero, err = dc.ReadBool()
			if err != nil {
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss0zxcj != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Field
var decodeMsgFieldOrder0zxcj = []string{"Zid", "FieldGoName", "FieldTagName", "FieldTypeStr", "FieldCategory", "FieldPrimitive", "FieldFullType", "OmitEmpty", "Skip", "Deprecated", "ShowZero"}

var decodeMsgFieldSkip0zxcj = []bool{false, false, false, false, false, false, false, false, false, false, false}

// ZebrafieldsNotEmpty supports omitempty tags
func (z *Field) ZebrafieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 11
	}
	var fieldsInUse uint32 = 11
	isempty[0] = (z.Zid == 0) // number, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.FieldGoName) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (len(z.FieldTagName) == 0) // string, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.FieldTypeStr) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (z.FieldCategory == 0) // number, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (z.FieldPrimitive == 0) // number, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (z.FieldFullType == nil) // pointer, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (!z.OmitEmpty) // bool, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (!z.Skip) // bool, omitempty
	if isempty[8] {
		fieldsInUse--
	}
	isempty[9] = (!z.Deprecated) // bool, omitempty
	if isempty[9] {
		fieldsInUse--
	}
	isempty[10] = (!z.ShowZero) // bool, omitempty
	if isempty[10] {
		fieldsInUse--
	}

	return fieldsInUse
}

// ZebraEncodeMsg implements msgp.Encodable
func (z *Field) ZebraEncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zkkw [11]bool
	fieldsInUse_zfsj := z.fieldsNotEmpty(empty_zkkw[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zfsj + 1)
	if err != nil {
		return err
	}

	// runtime struct type identification for 'Field'
	err = en.Append(0xff)
	if err != nil {
		return err
	}
	err = en.WriteStringFromBytes([]byte{0x46, 0x69, 0x65, 0x6c, 0x64})
	if err != nil {
		return err
	}

	if !empty_zkkw[0] {
		// zid 0 for "Zid"
		err = en.Append(0x0)
		if err != nil {
			return err
		}
		err = en.WriteInt64(z.Zid)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[1] {
		// zid 1 for "FieldGoName"
		err = en.Append(0x1)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldGoName)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[2] {
		// zid 2 for "FieldTagName"
		err = en.Append(0x2)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldTagName)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[3] {
		// zid 3 for "FieldTypeStr"
		err = en.Append(0x3)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldTypeStr)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[4] {
		// zid 4 for "FieldCategory"
		err = en.Append(0x4)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.FieldCategory))
		if err != nil {
			return
		}
	}

	if !empty_zkkw[5] {
		// zid 5 for "FieldPrimitive"
		err = en.Append(0x5)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.FieldPrimitive))
		if err != nil {
			return
		}
	}

	if !empty_zkkw[6] {
		// zid 6 for "FieldFullType"
		err = en.Append(0x6)
		if err != nil {
			return err
		}
		if z.FieldFullType == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.FieldFullType.ZebraEncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	if !empty_zkkw[7] {
		// zid 7 for "OmitEmpty"
		err = en.Append(0x7)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.OmitEmpty)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[8] {
		// zid 8 for "Skip"
		err = en.Append(0x8)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Skip)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[9] {
		// zid 9 for "Deprecated"
		err = en.Append(0x9)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Deprecated)
		if err != nil {
			return
		}
	}

	if !empty_zkkw[10] {
		// zid 10 for "ShowZero"
		err = en.Append(0xa)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.ShowZero)
		if err != nil {
			return
		}
	}

	return
}

// ZebraMarshalMsg implements msgp.Marshaler
func (z *Field) ZebraMarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.ZebraMsgsize())

	// honor the omitempty tags
	var empty [11]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse+1)

	// runtime struct type identification for 'Field'
	o = msgp.AppendNegativeOneAndStringAsBytes(o, []byte{0x46, 0x69, 0x65, 0x6c, 0x64})

	if !empty[0] {
		// zid 0 for "Zid"
		o = append(o, 0x0)
		o = msgp.AppendInt64(o, z.Zid)
	}

	if !empty[1] {
		// zid 1 for "FieldGoName"
		o = append(o, 0x1)
		o = msgp.AppendString(o, z.FieldGoName)
	}

	if !empty[2] {
		// zid 2 for "FieldTagName"
		o = append(o, 0x2)
		o = msgp.AppendString(o, z.FieldTagName)
	}

	if !empty[3] {
		// zid 3 for "FieldTypeStr"
		o = append(o, 0x3)
		o = msgp.AppendString(o, z.FieldTypeStr)
	}

	if !empty[4] {
		// zid 4 for "FieldCategory"
		o = append(o, 0x4)
		o = msgp.AppendUint64(o, uint64(z.FieldCategory))
	}

	if !empty[5] {
		// zid 5 for "FieldPrimitive"
		o = append(o, 0x5)
		o = msgp.AppendUint64(o, uint64(z.FieldPrimitive))
	}

	if !empty[6] {
		// zid 6 for "FieldFullType"
		o = append(o, 0x6)
		if z.FieldFullType == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.FieldFullType.ZebraMarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	if !empty[7] {
		// zid 7 for "OmitEmpty"
		o = append(o, 0x7)
		o = msgp.AppendBool(o, z.OmitEmpty)
	}

	if !empty[8] {
		// zid 8 for "Skip"
		o = append(o, 0x8)
		o = msgp.AppendBool(o, z.Skip)
	}

	if !empty[9] {
		// zid 9 for "Deprecated"
		o = append(o, 0x9)
		o = msgp.AppendBool(o, z.Deprecated)
	}

	if !empty[10] {
		// zid 10 for "ShowZero"
		o = append(o, 0xa)
		o = msgp.AppendBool(o, z.ShowZero)
	}

	return
}

// ZebraUnmarshalMsg implements msgp.Unmarshaler
func (z *Field) ZebraUnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.ZebraUnmarshalMsgWithCfg(bts, nil)
}
func (z *Field) ZebraUnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields1zzyc = 11

	// -- templateUnmarshalMsgZid starts here--
	var totalEncodedFields1zzyc uint32
	if !nbs.AlwaysNil {
		totalEncodedFields1zzyc, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft1zzyc := totalEncodedFields1zzyc
	missingFieldsLeft1zzyc := maxFields1zzyc - totalEncodedFields1zzyc

	var nextMiss1zzyc int = -1
	var found1zzyc [maxFields1zzyc]bool
	var curField1zzyc int

doneWithStruct1zzyc:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft1zzyc > 0 || missingFieldsLeft1zzyc > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft1zzyc, missingFieldsLeft1zzyc, msgp.ShowFound(found1zzyc[:]), unmarshalMsgFieldOrder1zzyc)
		if encodedFieldsLeft1zzyc > 0 {
			encodedFieldsLeft1zzyc--
			curField1zzyc, bts, err = nbs.ReadIntBytes(bts)
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss1zzyc < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss1zzyc = 0
			}
			for nextMiss1zzyc < maxFields1zzyc && (found1zzyc[nextMiss1zzyc] || unmarshalMsgFieldSkip1zzyc[nextMiss1zzyc]) {
				nextMiss1zzyc++
			}
			if nextMiss1zzyc == maxFields1zzyc {
				// filled all the empty fields!
				break doneWithStruct1zzyc
			}
			missingFieldsLeft1zzyc--
			curField1zzyc = nextMiss1zzyc
		}
		//fmt.Printf("switching on curField: '%v'\n", curField1zzyc)
		switch curField1zzyc {
		// -- templateUnmarshalMsgZid ends here --

		case 0:
			// zid 0 for "Zid"
			found1zzyc[0] = true
			z.Zid, bts, err = nbs.ReadInt64Bytes(bts)

			if err != nil {
				return
			}
		case 1:
			// zid 1 for "FieldGoName"
			found1zzyc[1] = true
			z.FieldGoName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 2:
			// zid 2 for "FieldTagName"
			found1zzyc[2] = true
			z.FieldTagName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 3:
			// zid 3 for "FieldTypeStr"
			found1zzyc[3] = true
			z.FieldTypeStr, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 4:
			// zid 4 for "FieldCategory"
			found1zzyc[4] = true
			{
				var zmzh uint64
				zmzh, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.FieldCategory = Zkind(zmzh)
			}
		case 5:
			// zid 5 for "FieldPrimitive"
			found1zzyc[5] = true
			{
				var zfah uint64
				zfah, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.FieldPrimitive = Zkind(zfah)
			}
		case 6:
			// zid 6 for "FieldFullType"
			found1zzyc[6] = true
			if nbs.AlwaysNil {
				if z.FieldFullType != nil {
					z.FieldFullType.ZebraUnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.FieldFullType {
						z.FieldFullType.ZebraUnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.FieldFullType == nil {
						z.FieldFullType = new(Ztype)
					}
					bts, err = z.FieldFullType.ZebraUnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		case 7:
			// zid 7 for "OmitEmpty"
			found1zzyc[7] = true
			z.OmitEmpty, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case 8:
			// zid 8 for "Skip"
			found1zzyc[8] = true
			z.Skip, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case 9:
			// zid 9 for "Deprecated"
			found1zzyc[9] = true
			z.Deprecated, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case 10:
			// zid 10 for "ShowZero"
			found1zzyc[10] = true
			z.ShowZero, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss1zzyc != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Field
var unmarshalMsgFieldOrder1zzyc = []string{"Zid", "FieldGoName", "FieldTagName", "FieldTypeStr", "FieldCategory", "FieldPrimitive", "FieldFullType", "OmitEmpty", "Skip", "Deprecated", "ShowZero"}

var unmarshalMsgFieldSkip1zzyc = []bool{false, false, false, false, false, false, false, false, false, false, false}

// ZebraMsgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Field) ZebraMsgsize() (s int) {
	s = 1 + 9 + msgp.Int64Size + 9 + msgp.StringPrefixSize + len(z.FieldGoName) + 9 + msgp.StringPrefixSize + len(z.FieldTagName) + 9 + msgp.StringPrefixSize + len(z.FieldTypeStr) + 9 + msgp.Uint64Size + 9 + msgp.Uint64Size + 9
	if z.FieldFullType == nil {
		s += msgp.NilSize
	} else {
		s += z.FieldFullType.ZebraMsgsize()
	}
	s += 9 + msgp.BoolSize + 9 + msgp.BoolSize + 9 + msgp.BoolSize + 9 + msgp.BoolSize
	return
}

// ZebraDecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Schema) ZebraDecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields2zmvp = 5

	// -- templateDecodeMsgZid starts here--
	var totalEncodedFields2zmvp uint32
	totalEncodedFields2zmvp, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft2zmvp := totalEncodedFields2zmvp
	missingFieldsLeft2zmvp := maxFields2zmvp - totalEncodedFields2zmvp

	var nextMiss2zmvp int = -1
	var found2zmvp [maxFields2zmvp]bool
	var curField2zmvp int

doneWithStruct2zmvp:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft2zmvp > 0 || missingFieldsLeft2zmvp > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft2zmvp, missingFieldsLeft2zmvp, msgp.ShowFound(found2zmvp[:]), decodeMsgFieldOrder2zmvp)
		if encodedFieldsLeft2zmvp > 0 {
			encodedFieldsLeft2zmvp--
			curField2zmvp, err = dc.ReadInt()
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss2zmvp < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss2zmvp = 0
			}
			for nextMiss2zmvp < maxFields2zmvp && (found2zmvp[nextMiss2zmvp] || decodeMsgFieldSkip2zmvp[nextMiss2zmvp]) {
				nextMiss2zmvp++
			}
			if nextMiss2zmvp == maxFields2zmvp {
				// filled all the empty fields!
				break doneWithStruct2zmvp
			}
			missingFieldsLeft2zmvp--
			curField2zmvp = nextMiss2zmvp
		}
		//fmt.Printf("switching on curField: '%v'\n", curField2zmvp)
		switch curField2zmvp {
		// -- templateDecodeMsgZid ends here --

		case 0:
			// zid 0 for "SourcePath"
			found2zmvp[0] = true
			z.SourcePath, err = dc.ReadString()
			if err != nil {
				return
			}
		case 1:
			// zid 1 for "SourcePackage"
			found2zmvp[1] = true
			z.SourcePackage, err = dc.ReadString()
			if err != nil {
				return
			}
		case 2:
			// zid 2 for "ZebraSchemaId"
			found2zmvp[2] = true
			z.ZebraSchemaId, err = dc.ReadInt64()
			if err != nil {
				return
			}
		case 3:
			// zid 3 for "Structs"
			found2zmvp[3] = true
			var zebt uint32
			zebt, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			if z.Structs == nil && zebt > 0 {
				z.Structs = make(map[string]*Struct, zebt)
			} else if len(z.Structs) > 0 {
				for key, _ := range z.Structs {
					delete(z.Structs, key)
				}
			}
			for zebt > 0 {
				zebt--
				var zopq string
				var zxvn *Struct
				zopq, err = dc.ReadString()
				if err != nil {
					return
				}
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					zxvn = nil
				} else {
					if zxvn == nil {
						zxvn = new(Struct)
					}
					const maxFields3zibc = 2

					// -- templateDecodeMsgZid starts here--
					var totalEncodedFields3zibc uint32
					totalEncodedFields3zibc, err = dc.ReadMapHeader()
					if err != nil {
						return
					}
					encodedFieldsLeft3zibc := totalEncodedFields3zibc
					missingFieldsLeft3zibc := maxFields3zibc - totalEncodedFields3zibc

					var nextMiss3zibc int = -1
					var found3zibc [maxFields3zibc]bool
					var curField3zibc int

				doneWithStruct3zibc:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft3zibc > 0 || missingFieldsLeft3zibc > 0 {
						//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft3zibc, missingFieldsLeft3zibc, msgp.ShowFound(found3zibc[:]), decodeMsgFieldOrder3zibc)
						if encodedFieldsLeft3zibc > 0 {
							encodedFieldsLeft3zibc--
							curField3zibc, err = dc.ReadInt()
							if err != nil {
								return
							}
						} else {
							//missing fields need handling
							if nextMiss3zibc < 0 {
								// tell the reader to only give us Nils
								// until further notice.
								dc.PushAlwaysNil()
								nextMiss3zibc = 0
							}
							for nextMiss3zibc < maxFields3zibc && (found3zibc[nextMiss3zibc] || decodeMsgFieldSkip3zibc[nextMiss3zibc]) {
								nextMiss3zibc++
							}
							if nextMiss3zibc == maxFields3zibc {
								// filled all the empty fields!
								break doneWithStruct3zibc
							}
							missingFieldsLeft3zibc--
							curField3zibc = nextMiss3zibc
						}
						//fmt.Printf("switching on curField: '%v'\n", curField3zibc)
						switch curField3zibc {
						// -- templateDecodeMsgZid ends here --

						case 0:
							// zid 0 for "StructName"
							found3zibc[0] = true
							zxvn.StructName, err = dc.ReadString()
							if err != nil {
								return
							}
						case 1:
							// zid 1 for "Fields"
							found3zibc[1] = true
							var zxos uint32
							zxos, err = dc.ReadArrayHeader()
							if err != nil {
								return
							}
							if cap(zxvn.Fields) >= int(zxos) {
								zxvn.Fields = (zxvn.Fields)[:zxos]
							} else {
								zxvn.Fields = make([]Field, zxos)
							}
							for zkzm := range zxvn.Fields {
								err = zxvn.Fields[zkzm].ZebraDecodeMsg(dc)
								if err != nil {
									return
								}
							}
						default:
							err = dc.Skip()
							if err != nil {
								return
							}
						}
					}
					if nextMiss3zibc != -1 {
						dc.PopAlwaysNil()
					}

				}
				z.Structs[zopq] = zxvn
			}
		case 4:
			// zid 4 for "Imports"
			found2zmvp[4] = true
			var zwio uint32
			zwio, err = dc.ReadArrayHeader()
			if err != nil {
				return
			}
			if cap(z.Imports) >= int(zwio) {
				z.Imports = (z.Imports)[:zwio]
			} else {
				z.Imports = make([]string, zwio)
			}
			for zjvf := range z.Imports {
				z.Imports[zjvf], err = dc.ReadString()
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss2zmvp != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Schema
var decodeMsgFieldOrder2zmvp = []string{"SourcePath", "SourcePackage", "ZebraSchemaId", "Structs", "Imports"}

var decodeMsgFieldSkip2zmvp = []bool{false, false, false, false, false}

// fields of Struct
var decodeMsgFieldOrder3zibc = []string{"StructName", "Fields"}

var decodeMsgFieldSkip3zibc = []bool{false, false}

// ZebrafieldsNotEmpty supports omitempty tags
func (z *Schema) ZebrafieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 5
	}
	var fieldsInUse uint32 = 5
	isempty[0] = (len(z.SourcePath) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.SourcePackage) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.ZebraSchemaId == 0) // number, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.Structs) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (len(z.Imports) == 0) // string, omitempty
	if isempty[4] {
		fieldsInUse--
	}

	return fieldsInUse
}

// ZebraEncodeMsg implements msgp.Encodable
func (z *Schema) ZebraEncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zrjz [5]bool
	fieldsInUse_zazb := z.fieldsNotEmpty(empty_zrjz[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zazb + 1)
	if err != nil {
		return err
	}

	// runtime struct type identification for 'Schema'
	err = en.Append(0xff)
	if err != nil {
		return err
	}
	err = en.WriteStringFromBytes([]byte{0x53, 0x63, 0x68, 0x65, 0x6d, 0x61})
	if err != nil {
		return err
	}

	if !empty_zrjz[0] {
		// zid 0 for "SourcePath"
		err = en.Append(0x0)
		if err != nil {
			return err
		}
		err = en.WriteString(z.SourcePath)
		if err != nil {
			return
		}
	}

	if !empty_zrjz[1] {
		// zid 1 for "SourcePackage"
		err = en.Append(0x1)
		if err != nil {
			return err
		}
		err = en.WriteString(z.SourcePackage)
		if err != nil {
			return
		}
	}

	if !empty_zrjz[2] {
		// zid 2 for "ZebraSchemaId"
		err = en.Append(0x2)
		if err != nil {
			return err
		}
		err = en.WriteInt64(z.ZebraSchemaId)
		if err != nil {
			return
		}
	}

	if !empty_zrjz[3] {
		// zid 3 for "Structs"
		err = en.Append(0x3)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Structs)))
		if err != nil {
			return
		}
		for zopq, zxvn := range z.Structs {
			err = en.WriteString(zopq)
			if err != nil {
				return
			}
			if zxvn == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {

				// honor the omitempty tags
				var empty_zetw [2]bool
				fieldsInUse_zjsc := zxvn.fieldsNotEmpty(empty_zetw[:])

				// map header
				err = en.WriteMapHeader(fieldsInUse_zjsc + 1)
				if err != nil {
					return err
				}

				// runtime struct type identification for 'Struct'
				err = en.Append(0xff)
				if err != nil {
					return err
				}
				err = en.WriteStringFromBytes([]byte{0x53, 0x74, 0x72, 0x75, 0x63, 0x74})
				if err != nil {
					return err
				}

				if !empty_zetw[0] {
					// zid 0 for "StructName"
					err = en.Append(0x0)
					if err != nil {
						return err
					}
					err = en.WriteString(zxvn.StructName)
					if err != nil {
						return
					}
				}

				if !empty_zetw[1] {
					// zid 1 for "Fields"
					err = en.Append(0x1)
					if err != nil {
						return err
					}
					err = en.WriteArrayHeader(uint32(len(zxvn.Fields)))
					if err != nil {
						return
					}
					for zkzm := range zxvn.Fields {
						err = zxvn.Fields[zkzm].ZebraEncodeMsg(en)
						if err != nil {
							return
						}
					}
				}

			}
		}
	}

	if !empty_zrjz[4] {
		// zid 4 for "Imports"
		err = en.Append(0x4)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Imports)))
		if err != nil {
			return
		}
		for zjvf := range z.Imports {
			err = en.WriteString(z.Imports[zjvf])
			if err != nil {
				return
			}
		}
	}

	return
}

// ZebraMarshalMsg implements msgp.Marshaler
func (z *Schema) ZebraMarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.ZebraMsgsize())

	// honor the omitempty tags
	var empty [5]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse+1)

	// runtime struct type identification for 'Schema'
	o = msgp.AppendNegativeOneAndStringAsBytes(o, []byte{0x53, 0x63, 0x68, 0x65, 0x6d, 0x61})

	if !empty[0] {
		// zid 0 for "SourcePath"
		o = append(o, 0x0)
		o = msgp.AppendString(o, z.SourcePath)
	}

	if !empty[1] {
		// zid 1 for "SourcePackage"
		o = append(o, 0x1)
		o = msgp.AppendString(o, z.SourcePackage)
	}

	if !empty[2] {
		// zid 2 for "ZebraSchemaId"
		o = append(o, 0x2)
		o = msgp.AppendInt64(o, z.ZebraSchemaId)
	}

	if !empty[3] {
		// zid 3 for "Structs"
		o = append(o, 0x3)
		o = msgp.AppendMapHeader(o, uint32(len(z.Structs)))
		for zopq, zxvn := range z.Structs {
			o = msgp.AppendString(o, zopq)
			if zxvn == nil {
				o = msgp.AppendNil(o)
			} else {

				// honor the omitempty tags
				var empty [2]bool
				fieldsInUse := zxvn.fieldsNotEmpty(empty[:])
				o = msgp.AppendMapHeader(o, fieldsInUse+1)

				// runtime struct type identification for 'Struct'
				o = msgp.AppendNegativeOneAndStringAsBytes(o, []byte{0x53, 0x74, 0x72, 0x75, 0x63, 0x74})

				if !empty[0] {
					// zid 0 for "StructName"
					o = append(o, 0x0)
					o = msgp.AppendString(o, zxvn.StructName)
				}

				if !empty[1] {
					// zid 1 for "Fields"
					o = append(o, 0x1)
					o = msgp.AppendArrayHeader(o, uint32(len(zxvn.Fields)))
					for zkzm := range zxvn.Fields {
						o, err = zxvn.Fields[zkzm].ZebraMarshalMsg(o)
						if err != nil {
							return
						}
					}
				}

			}
		}
	}

	if !empty[4] {
		// zid 4 for "Imports"
		o = append(o, 0x4)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Imports)))
		for zjvf := range z.Imports {
			o = msgp.AppendString(o, z.Imports[zjvf])
		}
	}

	return
}

// ZebraUnmarshalMsg implements msgp.Unmarshaler
func (z *Schema) ZebraUnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.ZebraUnmarshalMsgWithCfg(bts, nil)
}
func (z *Schema) ZebraUnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields4zdnh = 5

	// -- templateUnmarshalMsgZid starts here--
	var totalEncodedFields4zdnh uint32
	if !nbs.AlwaysNil {
		totalEncodedFields4zdnh, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft4zdnh := totalEncodedFields4zdnh
	missingFieldsLeft4zdnh := maxFields4zdnh - totalEncodedFields4zdnh

	var nextMiss4zdnh int = -1
	var found4zdnh [maxFields4zdnh]bool
	var curField4zdnh int

doneWithStruct4zdnh:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft4zdnh > 0 || missingFieldsLeft4zdnh > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft4zdnh, missingFieldsLeft4zdnh, msgp.ShowFound(found4zdnh[:]), unmarshalMsgFieldOrder4zdnh)
		if encodedFieldsLeft4zdnh > 0 {
			encodedFieldsLeft4zdnh--
			curField4zdnh, bts, err = nbs.ReadIntBytes(bts)
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss4zdnh < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss4zdnh = 0
			}
			for nextMiss4zdnh < maxFields4zdnh && (found4zdnh[nextMiss4zdnh] || unmarshalMsgFieldSkip4zdnh[nextMiss4zdnh]) {
				nextMiss4zdnh++
			}
			if nextMiss4zdnh == maxFields4zdnh {
				// filled all the empty fields!
				break doneWithStruct4zdnh
			}
			missingFieldsLeft4zdnh--
			curField4zdnh = nextMiss4zdnh
		}
		//fmt.Printf("switching on curField: '%v'\n", curField4zdnh)
		switch curField4zdnh {
		// -- templateUnmarshalMsgZid ends here --

		case 0:
			// zid 0 for "SourcePath"
			found4zdnh[0] = true
			z.SourcePath, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 1:
			// zid 1 for "SourcePackage"
			found4zdnh[1] = true
			z.SourcePackage, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 2:
			// zid 2 for "ZebraSchemaId"
			found4zdnh[2] = true
			z.ZebraSchemaId, bts, err = nbs.ReadInt64Bytes(bts)

			if err != nil {
				return
			}
		case 3:
			// zid 3 for "Structs"
			found4zdnh[3] = true
			if nbs.AlwaysNil {
				if len(z.Structs) > 0 {
					for key, _ := range z.Structs {
						delete(z.Structs, key)
					}
				}

			} else {

				var zvwd uint32
				zvwd, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				if z.Structs == nil && zvwd > 0 {
					z.Structs = make(map[string]*Struct, zvwd)
				} else if len(z.Structs) > 0 {
					for key, _ := range z.Structs {
						delete(z.Structs, key)
					}
				}
				for zvwd > 0 {
					var zopq string
					var zxvn *Struct
					zvwd--
					zopq, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						return
					}
					// default gPtr logic.
					if nbs.PeekNil(bts) && zxvn == nil {
						// consume the nil
						bts, err = nbs.ReadNilBytes(bts)
						if err != nil {
							return
						}
					} else {
						// read as-if the wire has bytes, letting nbs take care of nils.

						if zxvn == nil {
							zxvn = new(Struct)
						}
						const maxFields5zwdj = 2

						// -- templateUnmarshalMsgZid starts here--
						var totalEncodedFields5zwdj uint32
						if !nbs.AlwaysNil {
							totalEncodedFields5zwdj, bts, err = nbs.ReadMapHeaderBytes(bts)
							if err != nil {
								return
							}
						}
						encodedFieldsLeft5zwdj := totalEncodedFields5zwdj
						missingFieldsLeft5zwdj := maxFields5zwdj - totalEncodedFields5zwdj

						var nextMiss5zwdj int = -1
						var found5zwdj [maxFields5zwdj]bool
						var curField5zwdj int

					doneWithStruct5zwdj:
						// First fill all the encoded fields, then
						// treat the remaining, missing fields, as Nil.
						for encodedFieldsLeft5zwdj > 0 || missingFieldsLeft5zwdj > 0 {
							//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft5zwdj, missingFieldsLeft5zwdj, msgp.ShowFound(found5zwdj[:]), unmarshalMsgFieldOrder5zwdj)
							if encodedFieldsLeft5zwdj > 0 {
								encodedFieldsLeft5zwdj--
								curField5zwdj, bts, err = nbs.ReadIntBytes(bts)
								if err != nil {
									return
								}
							} else {
								//missing fields need handling
								if nextMiss5zwdj < 0 {
									// set bts to contain just mnil (0xc0)
									bts = nbs.PushAlwaysNil(bts)
									nextMiss5zwdj = 0
								}
								for nextMiss5zwdj < maxFields5zwdj && (found5zwdj[nextMiss5zwdj] || unmarshalMsgFieldSkip5zwdj[nextMiss5zwdj]) {
									nextMiss5zwdj++
								}
								if nextMiss5zwdj == maxFields5zwdj {
									// filled all the empty fields!
									break doneWithStruct5zwdj
								}
								missingFieldsLeft5zwdj--
								curField5zwdj = nextMiss5zwdj
							}
							//fmt.Printf("switching on curField: '%v'\n", curField5zwdj)
							switch curField5zwdj {
							// -- templateUnmarshalMsgZid ends here --

							case 0:
								// zid 0 for "StructName"
								found5zwdj[0] = true
								zxvn.StructName, bts, err = nbs.ReadStringBytes(bts)

								if err != nil {
									return
								}
							case 1:
								// zid 1 for "Fields"
								found5zwdj[1] = true
								if nbs.AlwaysNil {
									(zxvn.Fields) = (zxvn.Fields)[:0]
								} else {

									var zqsk uint32
									zqsk, bts, err = nbs.ReadArrayHeaderBytes(bts)
									if err != nil {
										return
									}
									if cap(zxvn.Fields) >= int(zqsk) {
										zxvn.Fields = (zxvn.Fields)[:zqsk]
									} else {
										zxvn.Fields = make([]Field, zqsk)
									}
									for zkzm := range zxvn.Fields {
										bts, err = zxvn.Fields[zkzm].ZebraUnmarshalMsg(bts)
										if err != nil {
											return
										}
										if err != nil {
											return
										}
									}
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									return
								}
							}
						}
						if nextMiss5zwdj != -1 {
							bts = nbs.PopAlwaysNil()
						}

					}
					z.Structs[zopq] = zxvn
				}
			}
		case 4:
			// zid 4 for "Imports"
			found4zdnh[4] = true
			if nbs.AlwaysNil {
				(z.Imports) = (z.Imports)[:0]
			} else {

				var zxsa uint32
				zxsa, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.Imports) >= int(zxsa) {
					z.Imports = (z.Imports)[:zxsa]
				} else {
					z.Imports = make([]string, zxsa)
				}
				for zjvf := range z.Imports {
					z.Imports[zjvf], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss4zdnh != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Schema
var unmarshalMsgFieldOrder4zdnh = []string{"SourcePath", "SourcePackage", "ZebraSchemaId", "Structs", "Imports"}

var unmarshalMsgFieldSkip4zdnh = []bool{false, false, false, false, false}

// fields of Struct
var unmarshalMsgFieldOrder5zwdj = []string{"StructName", "Fields"}

var unmarshalMsgFieldSkip5zwdj = []bool{false, false}

// ZebraMsgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Schema) ZebraMsgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.SourcePath) + 10 + msgp.StringPrefixSize + len(z.SourcePackage) + 10 + msgp.Int64Size + 10 + msgp.MapHeaderSize
	if z.Structs != nil {
		for zopq, zxvn := range z.Structs {
			_ = zxvn
			_ = zopq
			s += msgp.StringPrefixSize + len(zopq)
			if zxvn == nil {
				s += msgp.NilSize
			} else {
				s += 1 + 10 + msgp.StringPrefixSize + len(zxvn.StructName) + 10 + msgp.ArrayHeaderSize
				for zkzm := range zxvn.Fields {
					s += zxvn.Fields[zkzm].ZebraMsgsize()
				}
			}
		}
	}
	s += 10 + msgp.ArrayHeaderSize
	for zjvf := range z.Imports {
		s += msgp.StringPrefixSize + len(z.Imports[zjvf])
	}
	return
}

// ZebraDecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Struct) ZebraDecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields6zbxq = 2

	// -- templateDecodeMsgZid starts here--
	var totalEncodedFields6zbxq uint32
	totalEncodedFields6zbxq, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft6zbxq := totalEncodedFields6zbxq
	missingFieldsLeft6zbxq := maxFields6zbxq - totalEncodedFields6zbxq

	var nextMiss6zbxq int = -1
	var found6zbxq [maxFields6zbxq]bool
	var curField6zbxq int

doneWithStruct6zbxq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft6zbxq > 0 || missingFieldsLeft6zbxq > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft6zbxq, missingFieldsLeft6zbxq, msgp.ShowFound(found6zbxq[:]), decodeMsgFieldOrder6zbxq)
		if encodedFieldsLeft6zbxq > 0 {
			encodedFieldsLeft6zbxq--
			curField6zbxq, err = dc.ReadInt()
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss6zbxq < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss6zbxq = 0
			}
			for nextMiss6zbxq < maxFields6zbxq && (found6zbxq[nextMiss6zbxq] || decodeMsgFieldSkip6zbxq[nextMiss6zbxq]) {
				nextMiss6zbxq++
			}
			if nextMiss6zbxq == maxFields6zbxq {
				// filled all the empty fields!
				break doneWithStruct6zbxq
			}
			missingFieldsLeft6zbxq--
			curField6zbxq = nextMiss6zbxq
		}
		//fmt.Printf("switching on curField: '%v'\n", curField6zbxq)
		switch curField6zbxq {
		// -- templateDecodeMsgZid ends here --

		case 0:
			// zid 0 for "StructName"
			found6zbxq[0] = true
			z.StructName, err = dc.ReadString()
			if err != nil {
				return
			}
		case 1:
			// zid 1 for "Fields"
			found6zbxq[1] = true
			var zzfh uint32
			zzfh, err = dc.ReadArrayHeader()
			if err != nil {
				return
			}
			if cap(z.Fields) >= int(zzfh) {
				z.Fields = (z.Fields)[:zzfh]
			} else {
				z.Fields = make([]Field, zzfh)
			}
			for znsv := range z.Fields {
				err = z.Fields[znsv].ZebraDecodeMsg(dc)
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss6zbxq != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Struct
var decodeMsgFieldOrder6zbxq = []string{"StructName", "Fields"}

var decodeMsgFieldSkip6zbxq = []bool{false, false}

// ZebrafieldsNotEmpty supports omitempty tags
func (z *Struct) ZebrafieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 2
	}
	var fieldsInUse uint32 = 2
	isempty[0] = (len(z.StructName) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Fields) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// ZebraEncodeMsg implements msgp.Encodable
func (z *Struct) ZebraEncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_ztkk [2]bool
	fieldsInUse_zzca := z.fieldsNotEmpty(empty_ztkk[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zzca + 1)
	if err != nil {
		return err
	}

	// runtime struct type identification for 'Struct'
	err = en.Append(0xff)
	if err != nil {
		return err
	}
	err = en.WriteStringFromBytes([]byte{0x53, 0x74, 0x72, 0x75, 0x63, 0x74})
	if err != nil {
		return err
	}

	if !empty_ztkk[0] {
		// zid 0 for "StructName"
		err = en.Append(0x0)
		if err != nil {
			return err
		}
		err = en.WriteString(z.StructName)
		if err != nil {
			return
		}
	}

	if !empty_ztkk[1] {
		// zid 1 for "Fields"
		err = en.Append(0x1)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Fields)))
		if err != nil {
			return
		}
		for znsv := range z.Fields {
			err = z.Fields[znsv].ZebraEncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	return
}

// ZebraMarshalMsg implements msgp.Marshaler
func (z *Struct) ZebraMarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.ZebraMsgsize())

	// honor the omitempty tags
	var empty [2]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse+1)

	// runtime struct type identification for 'Struct'
	o = msgp.AppendNegativeOneAndStringAsBytes(o, []byte{0x53, 0x74, 0x72, 0x75, 0x63, 0x74})

	if !empty[0] {
		// zid 0 for "StructName"
		o = append(o, 0x0)
		o = msgp.AppendString(o, z.StructName)
	}

	if !empty[1] {
		// zid 1 for "Fields"
		o = append(o, 0x1)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Fields)))
		for znsv := range z.Fields {
			o, err = z.Fields[znsv].ZebraMarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	return
}

// ZebraUnmarshalMsg implements msgp.Unmarshaler
func (z *Struct) ZebraUnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.ZebraUnmarshalMsgWithCfg(bts, nil)
}
func (z *Struct) ZebraUnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields7zzcq = 2

	// -- templateUnmarshalMsgZid starts here--
	var totalEncodedFields7zzcq uint32
	if !nbs.AlwaysNil {
		totalEncodedFields7zzcq, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft7zzcq := totalEncodedFields7zzcq
	missingFieldsLeft7zzcq := maxFields7zzcq - totalEncodedFields7zzcq

	var nextMiss7zzcq int = -1
	var found7zzcq [maxFields7zzcq]bool
	var curField7zzcq int

doneWithStruct7zzcq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft7zzcq > 0 || missingFieldsLeft7zzcq > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft7zzcq, missingFieldsLeft7zzcq, msgp.ShowFound(found7zzcq[:]), unmarshalMsgFieldOrder7zzcq)
		if encodedFieldsLeft7zzcq > 0 {
			encodedFieldsLeft7zzcq--
			curField7zzcq, bts, err = nbs.ReadIntBytes(bts)
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss7zzcq < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss7zzcq = 0
			}
			for nextMiss7zzcq < maxFields7zzcq && (found7zzcq[nextMiss7zzcq] || unmarshalMsgFieldSkip7zzcq[nextMiss7zzcq]) {
				nextMiss7zzcq++
			}
			if nextMiss7zzcq == maxFields7zzcq {
				// filled all the empty fields!
				break doneWithStruct7zzcq
			}
			missingFieldsLeft7zzcq--
			curField7zzcq = nextMiss7zzcq
		}
		//fmt.Printf("switching on curField: '%v'\n", curField7zzcq)
		switch curField7zzcq {
		// -- templateUnmarshalMsgZid ends here --

		case 0:
			// zid 0 for "StructName"
			found7zzcq[0] = true
			z.StructName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 1:
			// zid 1 for "Fields"
			found7zzcq[1] = true
			if nbs.AlwaysNil {
				(z.Fields) = (z.Fields)[:0]
			} else {

				var znud uint32
				znud, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.Fields) >= int(znud) {
					z.Fields = (z.Fields)[:znud]
				} else {
					z.Fields = make([]Field, znud)
				}
				for znsv := range z.Fields {
					bts, err = z.Fields[znsv].ZebraUnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss7zzcq != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Struct
var unmarshalMsgFieldOrder7zzcq = []string{"StructName", "Fields"}

var unmarshalMsgFieldSkip7zzcq = []bool{false, false}

// ZebraMsgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Struct) ZebraMsgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.StructName) + 10 + msgp.ArrayHeaderSize
	for znsv := range z.Fields {
		s += z.Fields[znsv].ZebraMsgsize()
	}
	return
}

// ZebraDecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Zkind) ZebraDecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zwai uint64
		zwai, err = dc.ReadUint64()
		(*z) = Zkind(zwai)
	}
	if err != nil {
		return
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// ZebraEncodeMsg implements msgp.Encodable
func (z Zkind) ZebraEncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteUint64(uint64(z))
	if err != nil {
		return
	}
	return
}

// ZebraMarshalMsg implements msgp.Marshaler
func (z Zkind) ZebraMarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.ZebraMsgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// ZebraUnmarshalMsg implements msgp.Unmarshaler
func (z *Zkind) ZebraUnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.ZebraUnmarshalMsgWithCfg(bts, nil)
}
func (z *Zkind) ZebraUnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zyvr uint64
		zyvr, bts, err = nbs.ReadUint64Bytes(bts)

		if err != nil {
			return
		}
		(*z) = Zkind(zyvr)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// ZebraMsgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Zkind) ZebraMsgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// ZebraDecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Ztype) ZebraDecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields8zitj = 4

	// -- templateDecodeMsgZid starts here--
	var totalEncodedFields8zitj uint32
	totalEncodedFields8zitj, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft8zitj := totalEncodedFields8zitj
	missingFieldsLeft8zitj := maxFields8zitj - totalEncodedFields8zitj

	var nextMiss8zitj int = -1
	var found8zitj [maxFields8zitj]bool
	var curField8zitj int

doneWithStruct8zitj:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft8zitj > 0 || missingFieldsLeft8zitj > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft8zitj, missingFieldsLeft8zitj, msgp.ShowFound(found8zitj[:]), decodeMsgFieldOrder8zitj)
		if encodedFieldsLeft8zitj > 0 {
			encodedFieldsLeft8zitj--
			curField8zitj, err = dc.ReadInt()
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss8zitj < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss8zitj = 0
			}
			for nextMiss8zitj < maxFields8zitj && (found8zitj[nextMiss8zitj] || decodeMsgFieldSkip8zitj[nextMiss8zitj]) {
				nextMiss8zitj++
			}
			if nextMiss8zitj == maxFields8zitj {
				// filled all the empty fields!
				break doneWithStruct8zitj
			}
			missingFieldsLeft8zitj--
			curField8zitj = nextMiss8zitj
		}
		//fmt.Printf("switching on curField: '%v'\n", curField8zitj)
		switch curField8zitj {
		// -- templateDecodeMsgZid ends here --

		case 0:
			// zid 0 for "Kind"
			found8zitj[0] = true
			{
				var zfvi uint64
				zfvi, err = dc.ReadUint64()
				z.Kind = Zkind(zfvi)
			}
			if err != nil {
				return
			}
		case 1:
			// zid 1 for "Str"
			found8zitj[1] = true
			z.Str, err = dc.ReadString()
			if err != nil {
				return
			}
		case 2:
			// zid 2 for "Domain"
			found8zitj[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Domain != nil {
					dc.PushAlwaysNil()
					err = z.Domain.ZebraDecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Domain == nil {
					z.Domain = new(Ztype)
				}
				err = z.Domain.ZebraDecodeMsg(dc)
				if err != nil {
					return
				}
			}
		case 3:
			// zid 3 for "Range"
			found8zitj[3] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Range != nil {
					dc.PushAlwaysNil()
					err = z.Range.ZebraDecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Range == nil {
					z.Range = new(Ztype)
				}
				err = z.Range.ZebraDecodeMsg(dc)
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss8zitj != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Ztype
var decodeMsgFieldOrder8zitj = []string{"Kind", "Str", "Domain", "Range"}

var decodeMsgFieldSkip8zitj = []bool{false, false, false, false}

// ZebrafieldsNotEmpty supports omitempty tags
func (z *Ztype) ZebrafieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 4
	}
	var fieldsInUse uint32 = 4
	isempty[0] = (z.Kind == 0) // number, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Str) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Domain == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (z.Range == nil) // pointer, omitempty
	if isempty[3] {
		fieldsInUse--
	}

	return fieldsInUse
}

// ZebraEncodeMsg implements msgp.Encodable
func (z *Ztype) ZebraEncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zqrk [4]bool
	fieldsInUse_zbef := z.fieldsNotEmpty(empty_zqrk[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zbef + 1)
	if err != nil {
		return err
	}

	// runtime struct type identification for 'Ztype'
	err = en.Append(0xff)
	if err != nil {
		return err
	}
	err = en.WriteStringFromBytes([]byte{0x5a, 0x74, 0x79, 0x70, 0x65})
	if err != nil {
		return err
	}

	if !empty_zqrk[0] {
		// zid 0 for "Kind"
		err = en.Append(0x0)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.Kind))
		if err != nil {
			return
		}
	}

	if !empty_zqrk[1] {
		// zid 1 for "Str"
		err = en.Append(0x1)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Str)
		if err != nil {
			return
		}
	}

	if !empty_zqrk[2] {
		// zid 2 for "Domain"
		err = en.Append(0x2)
		if err != nil {
			return err
		}
		if z.Domain == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Domain.ZebraEncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	if !empty_zqrk[3] {
		// zid 3 for "Range"
		err = en.Append(0x3)
		if err != nil {
			return err
		}
		if z.Range == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Range.ZebraEncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	return
}

// ZebraMarshalMsg implements msgp.Marshaler
func (z *Ztype) ZebraMarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.ZebraMsgsize())

	// honor the omitempty tags
	var empty [4]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse+1)

	// runtime struct type identification for 'Ztype'
	o = msgp.AppendNegativeOneAndStringAsBytes(o, []byte{0x5a, 0x74, 0x79, 0x70, 0x65})

	if !empty[0] {
		// zid 0 for "Kind"
		o = append(o, 0x0)
		o = msgp.AppendUint64(o, uint64(z.Kind))
	}

	if !empty[1] {
		// zid 1 for "Str"
		o = append(o, 0x1)
		o = msgp.AppendString(o, z.Str)
	}

	if !empty[2] {
		// zid 2 for "Domain"
		o = append(o, 0x2)
		if z.Domain == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Domain.ZebraMarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	if !empty[3] {
		// zid 3 for "Range"
		o = append(o, 0x3)
		if z.Range == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Range.ZebraMarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	return
}

// ZebraUnmarshalMsg implements msgp.Unmarshaler
func (z *Ztype) ZebraUnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.ZebraUnmarshalMsgWithCfg(bts, nil)
}
func (z *Ztype) ZebraUnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields9zpnh = 4

	// -- templateUnmarshalMsgZid starts here--
	var totalEncodedFields9zpnh uint32
	if !nbs.AlwaysNil {
		totalEncodedFields9zpnh, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft9zpnh := totalEncodedFields9zpnh
	missingFieldsLeft9zpnh := maxFields9zpnh - totalEncodedFields9zpnh

	var nextMiss9zpnh int = -1
	var found9zpnh [maxFields9zpnh]bool
	var curField9zpnh int

doneWithStruct9zpnh:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft9zpnh > 0 || missingFieldsLeft9zpnh > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft9zpnh, missingFieldsLeft9zpnh, msgp.ShowFound(found9zpnh[:]), unmarshalMsgFieldOrder9zpnh)
		if encodedFieldsLeft9zpnh > 0 {
			encodedFieldsLeft9zpnh--
			curField9zpnh, bts, err = nbs.ReadIntBytes(bts)
			if err != nil {
				return
			}
		} else {
			//missing fields need handling
			if nextMiss9zpnh < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss9zpnh = 0
			}
			for nextMiss9zpnh < maxFields9zpnh && (found9zpnh[nextMiss9zpnh] || unmarshalMsgFieldSkip9zpnh[nextMiss9zpnh]) {
				nextMiss9zpnh++
			}
			if nextMiss9zpnh == maxFields9zpnh {
				// filled all the empty fields!
				break doneWithStruct9zpnh
			}
			missingFieldsLeft9zpnh--
			curField9zpnh = nextMiss9zpnh
		}
		//fmt.Printf("switching on curField: '%v'\n", curField9zpnh)
		switch curField9zpnh {
		// -- templateUnmarshalMsgZid ends here --

		case 0:
			// zid 0 for "Kind"
			found9zpnh[0] = true
			{
				var zmrl uint64
				zmrl, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.Kind = Zkind(zmrl)
			}
		case 1:
			// zid 1 for "Str"
			found9zpnh[1] = true
			z.Str, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case 2:
			// zid 2 for "Domain"
			found9zpnh[2] = true
			if nbs.AlwaysNil {
				if z.Domain != nil {
					z.Domain.ZebraUnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Domain {
						z.Domain.ZebraUnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Domain == nil {
						z.Domain = new(Ztype)
					}
					bts, err = z.Domain.ZebraUnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		case 3:
			// zid 3 for "Range"
			found9zpnh[3] = true
			if nbs.AlwaysNil {
				if z.Range != nil {
					z.Range.ZebraUnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Range {
						z.Range.ZebraUnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Range == nil {
						z.Range = new(Ztype)
					}
					bts, err = z.Range.ZebraUnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss9zpnh != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Ztype
var unmarshalMsgFieldOrder9zpnh = []string{"Kind", "Str", "Domain", "Range"}

var unmarshalMsgFieldSkip9zpnh = []bool{false, false, false, false}

// ZebraMsgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ztype) ZebraMsgsize() (s int) {
	s = 1 + 9 + msgp.Uint64Size + 9 + msgp.StringPrefixSize + len(z.Str) + 9
	if z.Domain == nil {
		s += msgp.NilSize
	} else {
		s += z.Domain.ZebraMsgsize()
	}
	s += 9
	if z.Range == nil {
		s += msgp.NilSize
	} else {
		s += z.Range.ZebraMsgsize()
	}
	return
}

// FileZebra_zebra_go holds ZebraPack schema from file 'zebra.go'
type FileZebra_zebra_go struct{}

// ZebraZebraSchemaInMsgpack2Format provides the ZebraPack Schema in msgpack2 format, length 3442 bytes
func (FileZebra_zebra_go) ZebraZebraSchemaInMsgpack2Format() []byte {
	return []byte{
		0x84, 0xaa, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61,
		0x74, 0x68, 0xa8, 0x7a, 0x65, 0x62, 0x72, 0x61, 0x2e, 0x67,
		0x6f, 0xad, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61,
		0x63, 0x6b, 0x61, 0x67, 0x65, 0xa5, 0x7a, 0x65, 0x62, 0x72,
		0x61, 0xad, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68,
		0x65, 0x6d, 0x61, 0x49, 0x64, 0xd3, 0x00, 0x01, 0xa5, 0xa9,
		0x4b, 0xd4, 0x96, 0x24, 0xa7, 0x53, 0x74, 0x72, 0x75, 0x63,
		0x74, 0x73, 0x84, 0xa6, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74,
		0x82, 0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61,
		0x6d, 0x65, 0xa6, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0xa6,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x92, 0x88, 0xa3, 0x5a,
		0x69, 0x64, 0x00, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47,
		0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xaa, 0x53, 0x74, 0x72, 0x75,
		0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0xac, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xaa,
		0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65,
		0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65,
		0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65,
		0x67, 0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65,
		0x02, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c,
		0x6c, 0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e,
		0x64, 0x02, 0xa3, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72,
		0x69, 0x6e, 0x67, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d,
		0x70, 0x74, 0x79, 0xc3, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x01,
		0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61,
		0x6d, 0x65, 0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61,
		0x6d, 0x65, 0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53,
		0x74, 0x72, 0xa7, 0x5b, 0x5d, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65,
		0x67, 0x6f, 0x72, 0x79, 0x1a, 0xad, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x83,
		0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x1a, 0xa3, 0x53, 0x74, 0x72,
		0xa5, 0x53, 0x6c, 0x69, 0x63, 0x65, 0xa6, 0x44, 0x6f, 0x6d,
		0x61, 0x69, 0x6e, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x16,
		0xa3, 0x53, 0x74, 0x72, 0xa5, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0xc3, 0xa5, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x82, 0xaa, 0x53,
		0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0xa5,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0xa6, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x73, 0x9b, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x00, 0xab,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0xa3, 0x5a, 0x69, 0x64, 0xac, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xa3, 0x5a,
		0x69, 0x64, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79,
		0x70, 0x65, 0x53, 0x74, 0x72, 0xa5, 0x69, 0x6e, 0x74, 0x36,
		0x34, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74,
		0x65, 0x67, 0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76,
		0x65, 0x11, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75,
		0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69,
		0x6e, 0x64, 0x11, 0xa3, 0x53, 0x74, 0x72, 0xa5, 0x69, 0x6e,
		0x74, 0x36, 0x34, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x01, 0xab,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e,
		0x61, 0x6d, 0x65, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54,
		0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xab, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50,
		0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x02, 0xad,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54,
		0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x02,
		0xa3, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e,
		0x67, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x02, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61,
		0x6d, 0x65, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0xac, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50,
		0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x02, 0xad,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54,
		0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x02,
		0xa3, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e,
		0x67, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x03, 0xab, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65,
		0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65,
		0x53, 0x74, 0x72, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54,
		0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xac, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53,
		0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xad,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67,
		0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x02,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64,
		0x02, 0xa3, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69,
		0x6e, 0x67, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70,
		0x74, 0x79, 0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x04, 0xab,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74,
		0x65, 0x67, 0x6f, 0x72, 0x79, 0xac, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79,
		0x70, 0x65, 0x53, 0x74, 0x72, 0xa5, 0x5a, 0x6b, 0x69, 0x6e,
		0x64, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74,
		0x65, 0x67, 0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76,
		0x65, 0x0b, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75,
		0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69,
		0x6e, 0x64, 0x0b, 0xa3, 0x53, 0x74, 0x72, 0xa6, 0x75, 0x69,
		0x6e, 0x74, 0x36, 0x34, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45,
		0x6d, 0x70, 0x74, 0x79, 0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64,
		0x05, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e,
		0x61, 0x6d, 0x65, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50,
		0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69,
		0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0xac, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xa5,
		0x5a, 0x6b, 0x69, 0x6e, 0x64, 0xad, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x17,
		0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d,
		0x69, 0x74, 0x69, 0x76, 0x65, 0x0b, 0xad, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65,
		0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x0b, 0xa3, 0x53, 0x74,
		0x72, 0xa6, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0xa9, 0x4f,
		0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0xc3, 0x87,
		0xa3, 0x5a, 0x69, 0x64, 0x06, 0xab, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xad, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70,
		0x65, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67,
		0x4e, 0x61, 0x6d, 0x65, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xa6, 0x2a, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x1c, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46,
		0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x83, 0xa4, 0x4b,
		0x69, 0x6e, 0x64, 0x1c, 0xa3, 0x53, 0x74, 0x72, 0xa7, 0x50,
		0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0xa6, 0x44, 0x6f, 0x6d,
		0x61, 0x69, 0x6e, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x16,
		0xa3, 0x53, 0x74, 0x72, 0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65,
		0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x07, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xa9,
		0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61,
		0x6d, 0x65, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70,
		0x74, 0x79, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79,
		0x70, 0x65, 0x53, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f, 0x6c,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65,
		0x67, 0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65,
		0x12, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c,
		0x6c, 0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e,
		0x64, 0x12, 0xa3, 0x53, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f,
		0x6c, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x08, 0xab, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65,
		0xa4, 0x53, 0x6b, 0x69, 0x70, 0xac, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xa4, 0x53,
		0x6b, 0x69, 0x70, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54,
		0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xa4, 0x62, 0x6f, 0x6f,
		0x6c, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74,
		0x65, 0x67, 0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76,
		0x65, 0x12, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75,
		0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69,
		0x6e, 0x64, 0x12, 0xa3, 0x53, 0x74, 0x72, 0xa4, 0x62, 0x6f,
		0x6f, 0x6c, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70,
		0x74, 0x79, 0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x09, 0xab,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0xaa, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74,
		0x65, 0x64, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0xaa, 0x44, 0x65, 0x70, 0x72,
		0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0xac, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xa4,
		0x62, 0x6f, 0x6f, 0x6c, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x17, 0xae,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69,
		0x74, 0x69, 0x76, 0x65, 0x12, 0xad, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x82,
		0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x12, 0xa3, 0x53, 0x74, 0x72,
		0xa4, 0x62, 0x6f, 0x6f, 0x6c, 0xa9, 0x4f, 0x6d, 0x69, 0x74,
		0x45, 0x6d, 0x70, 0x74, 0x79, 0xc3, 0x88, 0xa3, 0x5a, 0x69,
		0x64, 0x0a, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f,
		0x4e, 0x61, 0x6d, 0x65, 0xa8, 0x53, 0x68, 0x6f, 0x77, 0x5a,
		0x65, 0x72, 0x6f, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54,
		0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xa8, 0x53, 0x68, 0x6f,
		0x77, 0x5a, 0x65, 0x72, 0x6f, 0xac, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xa4, 0x62,
		0x6f, 0x6f, 0x6c, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43,
		0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x17, 0xae, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74,
		0x69, 0x76, 0x65, 0x12, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x82, 0xa4,
		0x4b, 0x69, 0x6e, 0x64, 0x12, 0xa3, 0x53, 0x74, 0x72, 0xa4,
		0x62, 0x6f, 0x6f, 0x6c, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45,
		0x6d, 0x70, 0x74, 0x79, 0xc3, 0xa5, 0x5a, 0x74, 0x79, 0x70,
		0x65, 0x82, 0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e,
		0x61, 0x6d, 0x65, 0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xa6,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x94, 0x87, 0xa3, 0x5a,
		0x69, 0x64, 0x00, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47,
		0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xa4, 0x4b, 0x69, 0x6e, 0x64,
		0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e,
		0x61, 0x6d, 0x65, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xa5, 0x5a, 0x6b, 0x69, 0x6e, 0x64, 0xad, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
		0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72,
		0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x0b, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79,
		0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x0b, 0xa3,
		0x53, 0x74, 0x72, 0xa6, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34,
		0x88, 0xa3, 0x5a, 0x69, 0x64, 0x01, 0xab, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xa3, 0x53,
		0x74, 0x72, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61,
		0x67, 0x4e, 0x61, 0x6d, 0x65, 0xa3, 0x53, 0x74, 0x72, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53,
		0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xad,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67,
		0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x02,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64,
		0x02, 0xa3, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69,
		0x6e, 0x67, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70,
		0x74, 0x79, 0xc3, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x02, 0xab,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d,
		0x65, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xa6, 0x2a, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f,
		0x72, 0x79, 0x1c, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46,
		0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x83, 0xa4, 0x4b,
		0x69, 0x6e, 0x64, 0x1c, 0xa3, 0x53, 0x74, 0x72, 0xa7, 0x50,
		0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0xa6, 0x44, 0x6f, 0x6d,
		0x61, 0x69, 0x6e, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x16,
		0xa3, 0x53, 0x74, 0x72, 0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65,
		0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0xc3, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x03, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xa5,
		0x52, 0x61, 0x6e, 0x67, 0x65, 0xac, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xa5, 0x52,
		0x61, 0x6e, 0x67, 0x65, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xa6, 0x2a, 0x5a,
		0x74, 0x79, 0x70, 0x65, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x1c, 0xad,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54,
		0x79, 0x70, 0x65, 0x83, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x1c,
		0xa3, 0x53, 0x74, 0x72, 0xa7, 0x50, 0x6f, 0x69, 0x6e, 0x74,
		0x65, 0x72, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x82,
		0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x16, 0xa3, 0x53, 0x74, 0x72,
		0xa5, 0x5a, 0x74, 0x79, 0x70, 0x65, 0xa9, 0x4f, 0x6d, 0x69,
		0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0xc3, 0xa6, 0x53, 0x63,
		0x68, 0x65, 0x6d, 0x61, 0x82, 0xaa, 0x53, 0x74, 0x72, 0x75,
		0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0xa6, 0x53, 0x63, 0x68,
		0x65, 0x6d, 0x61, 0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73,
		0x95, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x00, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xaa,
		0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x74, 0x68,
		0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e,
		0x61, 0x6d, 0x65, 0xaa, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65,
		0x50, 0x61, 0x74, 0x68, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74,
		0x72, 0x69, 0x6e, 0x67, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x17, 0xae,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69,
		0x74, 0x69, 0x76, 0x65, 0x02, 0xad, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x82,
		0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x02, 0xa3, 0x53, 0x74, 0x72,
		0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xa9, 0x4f, 0x6d,
		0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79, 0xc3, 0x88, 0xa3,
		0x5a, 0x69, 0x64, 0x01, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xad, 0x53, 0x6f, 0x75,
		0x72, 0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
		0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e,
		0x61, 0x6d, 0x65, 0xad, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65,
		0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0xac, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72,
		0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0xad, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
		0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72,
		0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x02, 0xad, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79,
		0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x02, 0xa3,
		0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
		0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0xc3, 0x88, 0xa3, 0x5a, 0x69, 0x64, 0x02, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xad,
		0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d,
		0x61, 0x49, 0x64, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54,
		0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0xad, 0x5a, 0x65, 0x62,
		0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x49, 0x64,
		0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65,
		0x53, 0x74, 0x72, 0xa5, 0x69, 0x6e, 0x74, 0x36, 0x34, 0xad,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67,
		0x6f, 0x72, 0x79, 0x17, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64,
		0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x11,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c,
		0x54, 0x79, 0x70, 0x65, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64,
		0x11, 0xa3, 0x53, 0x74, 0x72, 0xa5, 0x69, 0x6e, 0x74, 0x36,
		0x34, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0xc3, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x03, 0xab, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65,
		0xa7, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d,
		0x65, 0xa7, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0xac,
		0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53,
		0x74, 0x72, 0xb2, 0x6d, 0x61, 0x70, 0x5b, 0x73, 0x74, 0x72,
		0x69, 0x6e, 0x67, 0x5d, 0x2a, 0x53, 0x74, 0x72, 0x75, 0x63,
		0x74, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74,
		0x65, 0x67, 0x6f, 0x72, 0x79, 0x18, 0xad, 0x46, 0x69, 0x65,
		0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65,
		0x84, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x18, 0xa3, 0x53, 0x74,
		0x72, 0xa3, 0x4d, 0x61, 0x70, 0xa6, 0x44, 0x6f, 0x6d, 0x61,
		0x69, 0x6e, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x02, 0xa3,
		0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
		0xa5, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x83, 0xa4, 0x4b, 0x69,
		0x6e, 0x64, 0x1c, 0xa3, 0x53, 0x74, 0x72, 0xa7, 0x50, 0x6f,
		0x69, 0x6e, 0x74, 0x65, 0x72, 0xa6, 0x44, 0x6f, 0x6d, 0x61,
		0x69, 0x6e, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x19, 0xa3,
		0x53, 0x74, 0x72, 0xa6, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74,
		0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79,
		0xc3, 0x87, 0xa3, 0x5a, 0x69, 0x64, 0x04, 0xab, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65, 0xa7,
		0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xac, 0x46, 0x69,
		0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65,
		0xa7, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xac, 0x46,
		0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74,
		0x72, 0xa8, 0x5b, 0x5d, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
		0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65,
		0x67, 0x6f, 0x72, 0x79, 0x1a, 0xad, 0x46, 0x69, 0x65, 0x6c,
		0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x83,
		0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x1a, 0xa3, 0x53, 0x74, 0x72,
		0xa5, 0x53, 0x6c, 0x69, 0x63, 0x65, 0xa6, 0x44, 0x6f, 0x6d,
		0x61, 0x69, 0x6e, 0x82, 0xa4, 0x4b, 0x69, 0x6e, 0x64, 0x02,
		0xa3, 0x53, 0x74, 0x72, 0xa6, 0x73, 0x74, 0x72, 0x69, 0x6e,
		0x67, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74,
		0x79, 0xc3,
	}
}

// ZebraZebraSchemaInJsonCompact provides the ZebraPack Schema in compact JSON format, length 4435 bytes
func (FileZebra_zebra_go) ZebraZebraSchemaInJsonCompact() []byte {
	return []byte(`{"SourcePath":"zebra.go","SourcePackage":"zebra","ZebraSchemaId":463621516989988,"Structs":{"Struct":{"StructName":"Struct","Fields":[{"Zid":0,"FieldGoName":"StructName","FieldTagName":"StructName","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"},"OmitEmpty":true},{"Zid":1,"FieldGoName":"Fields","FieldTagName":"Fields","FieldTypeStr":"[]Field","FieldCategory":26,"FieldFullType":{"Kind":26,"Str":"Slice","Domain":{"Kind":22,"Str":"Field"}},"OmitEmpty":true}]},"Field":{"StructName":"Field","Fields":[{"Zid":0,"FieldGoName":"Zid","FieldTagName":"Zid","FieldTypeStr":"int64","FieldCategory":23,"FieldPrimitive":17,"FieldFullType":{"Kind":17,"Str":"int64"}},{"Zid":1,"FieldGoName":"FieldGoName","FieldTagName":"FieldGoName","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"}},{"Zid":2,"FieldGoName":"FieldTagName","FieldTagName":"FieldTagName","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"},"OmitEmpty":true},{"Zid":3,"FieldGoName":"FieldTypeStr","FieldTagName":"FieldTypeStr","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"},"OmitEmpty":true},{"Zid":4,"FieldGoName":"FieldCategory","FieldTagName":"FieldCategory","FieldTypeStr":"Zkind","FieldCategory":23,"FieldPrimitive":11,"FieldFullType":{"Kind":11,"Str":"uint64"},"OmitEmpty":true},{"Zid":5,"FieldGoName":"FieldPrimitive","FieldTagName":"FieldPrimitive","FieldTypeStr":"Zkind","FieldCategory":23,"FieldPrimitive":11,"FieldFullType":{"Kind":11,"Str":"uint64"},"OmitEmpty":true},{"Zid":6,"FieldGoName":"FieldFullType","FieldTagName":"FieldFullType","FieldTypeStr":"*Ztype","FieldCategory":28,"FieldFullType":{"Kind":28,"Str":"Pointer","Domain":{"Kind":22,"Str":"Ztype"}},"OmitEmpty":true},{"Zid":7,"FieldGoName":"OmitEmpty","FieldTagName":"OmitEmpty","FieldTypeStr":"bool","FieldCategory":23,"FieldPrimitive":18,"FieldFullType":{"Kind":18,"Str":"bool"},"OmitEmpty":true},{"Zid":8,"FieldGoName":"Skip","FieldTagName":"Skip","FieldTypeStr":"bool","FieldCategory":23,"FieldPrimitive":18,"FieldFullType":{"Kind":18,"Str":"bool"},"OmitEmpty":true},{"Zid":9,"FieldGoName":"Deprecated","FieldTagName":"Deprecated","FieldTypeStr":"bool","FieldCategory":23,"FieldPrimitive":18,"FieldFullType":{"Kind":18,"Str":"bool"},"OmitEmpty":true},{"Zid":10,"FieldGoName":"ShowZero","FieldTagName":"ShowZero","FieldTypeStr":"bool","FieldCategory":23,"FieldPrimitive":18,"FieldFullType":{"Kind":18,"Str":"bool"},"OmitEmpty":true}]},"Ztype":{"StructName":"Ztype","Fields":[{"Zid":0,"FieldGoName":"Kind","FieldTagName":"Kind","FieldTypeStr":"Zkind","FieldCategory":23,"FieldPrimitive":11,"FieldFullType":{"Kind":11,"Str":"uint64"}},{"Zid":1,"FieldGoName":"Str","FieldTagName":"Str","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"},"OmitEmpty":true},{"Zid":2,"FieldGoName":"Domain","FieldTagName":"Domain","FieldTypeStr":"*Ztype","FieldCategory":28,"FieldFullType":{"Kind":28,"Str":"Pointer","Domain":{"Kind":22,"Str":"Ztype"}},"OmitEmpty":true},{"Zid":3,"FieldGoName":"Range","FieldTagName":"Range","FieldTypeStr":"*Ztype","FieldCategory":28,"FieldFullType":{"Kind":28,"Str":"Pointer","Domain":{"Kind":22,"Str":"Ztype"}},"OmitEmpty":true}]},"Schema":{"StructName":"Schema","Fields":[{"Zid":0,"FieldGoName":"SourcePath","FieldTagName":"SourcePath","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"},"OmitEmpty":true},{"Zid":1,"FieldGoName":"SourcePackage","FieldTagName":"SourcePackage","FieldTypeStr":"string","FieldCategory":23,"FieldPrimitive":2,"FieldFullType":{"Kind":2,"Str":"string"},"OmitEmpty":true},{"Zid":2,"FieldGoName":"ZebraSchemaId","FieldTagName":"ZebraSchemaId","FieldTypeStr":"int64","FieldCategory":23,"FieldPrimitive":17,"FieldFullType":{"Kind":17,"Str":"int64"},"OmitEmpty":true},{"Zid":3,"FieldGoName":"Structs","FieldTagName":"Structs","FieldTypeStr":"map[string]*Struct","FieldCategory":24,"FieldFullType":{"Kind":24,"Str":"Map","Domain":{"Kind":2,"Str":"string"},"Range":{"Kind":28,"Str":"Pointer","Domain":{"Kind":25,"Str":"Struct"}}},"OmitEmpty":true},{"Zid":4,"FieldGoName":"Imports","FieldTagName":"Imports","FieldTypeStr":"[]string","FieldCategory":26,"FieldFullType":{"Kind":26,"Str":"Slice","Domain":{"Kind":2,"Str":"string"}},"OmitEmpty":true}]}}}`)
}

// ZebraZebraSchemaInJsonPretty provides the ZebraPack Schema in pretty JSON format, length 11637 bytes
func (FileZebra_zebra_go) ZebraZebraSchemaInJsonPretty() []byte {
	return []byte(`{
    "SourcePath": "zebra.go",
    "SourcePackage": "zebra",
    "ZebraSchemaId": 463621516989988,
    "Structs": {
        "Struct": {
            "StructName": "Struct",
            "Fields": [
                {
                    "Zid": 0,
                    "FieldGoName": "StructName",
                    "FieldTagName": "StructName",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 1,
                    "FieldGoName": "Fields",
                    "FieldTagName": "Fields",
                    "FieldTypeStr": "[]Field",
                    "FieldCategory": 26,
                    "FieldFullType": {
                        "Kind": 26,
                        "Str": "Slice",
                        "Domain": {
                            "Kind": 22,
                            "Str": "Field"
                        }
                    },
                    "OmitEmpty": true
                }
            ]
        },
        "Field": {
            "StructName": "Field",
            "Fields": [
                {
                    "Zid": 0,
                    "FieldGoName": "Zid",
                    "FieldTagName": "Zid",
                    "FieldTypeStr": "int64",
                    "FieldCategory": 23,
                    "FieldPrimitive": 17,
                    "FieldFullType": {
                        "Kind": 17,
                        "Str": "int64"
                    }
                },
                {
                    "Zid": 1,
                    "FieldGoName": "FieldGoName",
                    "FieldTagName": "FieldGoName",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    }
                },
                {
                    "Zid": 2,
                    "FieldGoName": "FieldTagName",
                    "FieldTagName": "FieldTagName",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 3,
                    "FieldGoName": "FieldTypeStr",
                    "FieldTagName": "FieldTypeStr",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 4,
                    "FieldGoName": "FieldCategory",
                    "FieldTagName": "FieldCategory",
                    "FieldTypeStr": "Zkind",
                    "FieldCategory": 23,
                    "FieldPrimitive": 11,
                    "FieldFullType": {
                        "Kind": 11,
                        "Str": "uint64"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 5,
                    "FieldGoName": "FieldPrimitive",
                    "FieldTagName": "FieldPrimitive",
                    "FieldTypeStr": "Zkind",
                    "FieldCategory": 23,
                    "FieldPrimitive": 11,
                    "FieldFullType": {
                        "Kind": 11,
                        "Str": "uint64"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 6,
                    "FieldGoName": "FieldFullType",
                    "FieldTagName": "FieldFullType",
                    "FieldTypeStr": "*Ztype",
                    "FieldCategory": 28,
                    "FieldFullType": {
                        "Kind": 28,
                        "Str": "Pointer",
                        "Domain": {
                            "Kind": 22,
                            "Str": "Ztype"
                        }
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 7,
                    "FieldGoName": "OmitEmpty",
                    "FieldTagName": "OmitEmpty",
                    "FieldTypeStr": "bool",
                    "FieldCategory": 23,
                    "FieldPrimitive": 18,
                    "FieldFullType": {
                        "Kind": 18,
                        "Str": "bool"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 8,
                    "FieldGoName": "Skip",
                    "FieldTagName": "Skip",
                    "FieldTypeStr": "bool",
                    "FieldCategory": 23,
                    "FieldPrimitive": 18,
                    "FieldFullType": {
                        "Kind": 18,
                        "Str": "bool"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 9,
                    "FieldGoName": "Deprecated",
                    "FieldTagName": "Deprecated",
                    "FieldTypeStr": "bool",
                    "FieldCategory": 23,
                    "FieldPrimitive": 18,
                    "FieldFullType": {
                        "Kind": 18,
                        "Str": "bool"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 10,
                    "FieldGoName": "ShowZero",
                    "FieldTagName": "ShowZero",
                    "FieldTypeStr": "bool",
                    "FieldCategory": 23,
                    "FieldPrimitive": 18,
                    "FieldFullType": {
                        "Kind": 18,
                        "Str": "bool"
                    },
                    "OmitEmpty": true
                }
            ]
        },
        "Ztype": {
            "StructName": "Ztype",
            "Fields": [
                {
                    "Zid": 0,
                    "FieldGoName": "Kind",
                    "FieldTagName": "Kind",
                    "FieldTypeStr": "Zkind",
                    "FieldCategory": 23,
                    "FieldPrimitive": 11,
                    "FieldFullType": {
                        "Kind": 11,
                        "Str": "uint64"
                    }
                },
                {
                    "Zid": 1,
                    "FieldGoName": "Str",
                    "FieldTagName": "Str",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 2,
                    "FieldGoName": "Domain",
                    "FieldTagName": "Domain",
                    "FieldTypeStr": "*Ztype",
                    "FieldCategory": 28,
                    "FieldFullType": {
                        "Kind": 28,
                        "Str": "Pointer",
                        "Domain": {
                            "Kind": 22,
                            "Str": "Ztype"
                        }
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 3,
                    "FieldGoName": "Range",
                    "FieldTagName": "Range",
                    "FieldTypeStr": "*Ztype",
                    "FieldCategory": 28,
                    "FieldFullType": {
                        "Kind": 28,
                        "Str": "Pointer",
                        "Domain": {
                            "Kind": 22,
                            "Str": "Ztype"
                        }
                    },
                    "OmitEmpty": true
                }
            ]
        },
        "Schema": {
            "StructName": "Schema",
            "Fields": [
                {
                    "Zid": 0,
                    "FieldGoName": "SourcePath",
                    "FieldTagName": "SourcePath",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 1,
                    "FieldGoName": "SourcePackage",
                    "FieldTagName": "SourcePackage",
                    "FieldTypeStr": "string",
                    "FieldCategory": 23,
                    "FieldPrimitive": 2,
                    "FieldFullType": {
                        "Kind": 2,
                        "Str": "string"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 2,
                    "FieldGoName": "ZebraSchemaId",
                    "FieldTagName": "ZebraSchemaId",
                    "FieldTypeStr": "int64",
                    "FieldCategory": 23,
                    "FieldPrimitive": 17,
                    "FieldFullType": {
                        "Kind": 17,
                        "Str": "int64"
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 3,
                    "FieldGoName": "Structs",
                    "FieldTagName": "Structs",
                    "FieldTypeStr": "map[string]*Struct",
                    "FieldCategory": 24,
                    "FieldFullType": {
                        "Kind": 24,
                        "Str": "Map",
                        "Domain": {
                            "Kind": 2,
                            "Str": "string"
                        },
                        "Range": {
                            "Kind": 28,
                            "Str": "Pointer",
                            "Domain": {
                                "Kind": 25,
                                "Str": "Struct"
                            }
                        }
                    },
                    "OmitEmpty": true
                },
                {
                    "Zid": 4,
                    "FieldGoName": "Imports",
                    "FieldTagName": "Imports",
                    "FieldTypeStr": "[]string",
                    "FieldCategory": 26,
                    "FieldFullType": {
                        "Kind": 26,
                        "Str": "Slice",
                        "Domain": {
                            "Kind": 2,
                            "Str": "string"
                        }
                    },
                    "OmitEmpty": true
                }
            ]
        }
    }
}`)
}
