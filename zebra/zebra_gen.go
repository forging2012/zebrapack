// Code generated by ZEBRAPACK (github.com/glycerine/zebrapack). DO NOT EDIT.

package zebra

import (
	"github.com/glycerine/zebrapack/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Field) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields0zobg = 11

	// -- templateDecodeMsg starts here--
	var totalEncodedFields0zobg uint32
	totalEncodedFields0zobg, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft0zobg := totalEncodedFields0zobg
	missingFieldsLeft0zobg := maxFields0zobg - totalEncodedFields0zobg

	var nextMiss0zobg int32 = -1
	var found0zobg [maxFields0zobg]bool
	var curField0zobg string

doneWithStruct0zobg:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft0zobg > 0 || missingFieldsLeft0zobg > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft0zobg, missingFieldsLeft0zobg, msgp.ShowFound(found0zobg[:]), decodeMsgFieldOrder0zobg)
		if encodedFieldsLeft0zobg > 0 {
			encodedFieldsLeft0zobg--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField0zobg = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss0zobg < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss0zobg = 0
			}
			for nextMiss0zobg < maxFields0zobg && (found0zobg[nextMiss0zobg] || decodeMsgFieldSkip0zobg[nextMiss0zobg]) {
				nextMiss0zobg++
			}
			if nextMiss0zobg == maxFields0zobg {
				// filled all the empty fields!
				break doneWithStruct0zobg
			}
			missingFieldsLeft0zobg--
			curField0zobg = decodeMsgFieldOrder0zobg[nextMiss0zobg]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField0zobg)
		switch curField0zobg {
		// -- templateDecodeMsg ends here --

		case "Zid":
			found0zobg[0] = true
			z.Zid, err = dc.ReadInt64()
			if err != nil {
				return
			}
		case "FieldGoName":
			found0zobg[1] = true
			z.FieldGoName, err = dc.ReadString()
			if err != nil {
				return
			}
		case "FieldTagName":
			found0zobg[2] = true
			z.FieldTagName, err = dc.ReadString()
			if err != nil {
				return
			}
		case "FieldTypeStr":
			found0zobg[3] = true
			z.FieldTypeStr, err = dc.ReadString()
			if err != nil {
				return
			}
		case "FieldCategory":
			found0zobg[4] = true
			{
				var ziod uint64
				ziod, err = dc.ReadUint64()
				z.FieldCategory = Zkind(ziod)
			}
			if err != nil {
				return
			}
		case "FieldPrimitive":
			found0zobg[5] = true
			{
				var zekw uint64
				zekw, err = dc.ReadUint64()
				z.FieldPrimitive = Zkind(zekw)
			}
			if err != nil {
				return
			}
		case "FieldFullType":
			found0zobg[6] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.FieldFullType != nil {
					dc.PushAlwaysNil()
					err = z.FieldFullType.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.FieldFullType == nil {
					z.FieldFullType = new(Ztype)
				}
				err = z.FieldFullType.DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		case "OmitEmpty":
			found0zobg[7] = true
			z.OmitEmpty, err = dc.ReadBool()
			if err != nil {
				return
			}
		case "Skip":
			found0zobg[8] = true
			z.Skip, err = dc.ReadBool()
			if err != nil {
				return
			}
		case "Deprecated":
			found0zobg[9] = true
			z.Deprecated, err = dc.ReadBool()
			if err != nil {
				return
			}
		case "ShowZero":
			found0zobg[10] = true
			z.ShowZero, err = dc.ReadBool()
			if err != nil {
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss0zobg != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Field
var decodeMsgFieldOrder0zobg = []string{"Zid", "FieldGoName", "FieldTagName", "FieldTypeStr", "FieldCategory", "FieldPrimitive", "FieldFullType", "OmitEmpty", "Skip", "Deprecated", "ShowZero"}

var decodeMsgFieldSkip0zobg = []bool{false, false, false, false, false, false, false, false, false, false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Field) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 11
	}
	var fieldsInUse uint32 = 11
	isempty[2] = (len(z.FieldTagName) == 0) // string, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.FieldTypeStr) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (z.FieldCategory == 0) // number, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (z.FieldPrimitive == 0) // number, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (z.FieldFullType == nil) // pointer, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (!z.OmitEmpty) // bool, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (!z.Skip) // bool, omitempty
	if isempty[8] {
		fieldsInUse--
	}
	isempty[9] = (!z.Deprecated) // bool, omitempty
	if isempty[9] {
		fieldsInUse--
	}
	isempty[10] = (!z.ShowZero) // bool, omitempty
	if isempty[10] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Field) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zjjx [11]bool
	fieldsInUse_zbsg := z.fieldsNotEmpty(empty_zjjx[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zbsg)
	if err != nil {
		return err
	}

	// write "Zid"
	err = en.Append(0xa3, 0x5a, 0x69, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt64(z.Zid)
	if err != nil {
		return
	}
	// write "FieldGoName"
	err = en.Append(0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteString(z.FieldGoName)
	if err != nil {
		return
	}
	if !empty_zjjx[2] {
		// write "FieldTagName"
		err = en.Append(0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldTagName)
		if err != nil {
			return
		}
	}

	if !empty_zjjx[3] {
		// write "FieldTypeStr"
		err = en.Append(0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72)
		if err != nil {
			return err
		}
		err = en.WriteString(z.FieldTypeStr)
		if err != nil {
			return
		}
	}

	if !empty_zjjx[4] {
		// write "FieldCategory"
		err = en.Append(0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.FieldCategory))
		if err != nil {
			return
		}
	}

	if !empty_zjjx[5] {
		// write "FieldPrimitive"
		err = en.Append(0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteUint64(uint64(z.FieldPrimitive))
		if err != nil {
			return
		}
	}

	if !empty_zjjx[6] {
		// write "FieldFullType"
		err = en.Append(0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65)
		if err != nil {
			return err
		}
		if z.FieldFullType == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.FieldFullType.EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	if !empty_zjjx[7] {
		// write "OmitEmpty"
		err = en.Append(0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.OmitEmpty)
		if err != nil {
			return
		}
	}

	if !empty_zjjx[8] {
		// write "Skip"
		err = en.Append(0xa4, 0x53, 0x6b, 0x69, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Skip)
		if err != nil {
			return
		}
	}

	if !empty_zjjx[9] {
		// write "Deprecated"
		err = en.Append(0xaa, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Deprecated)
		if err != nil {
			return
		}
	}

	if !empty_zjjx[10] {
		// write "ShowZero"
		err = en.Append(0xa8, 0x53, 0x68, 0x6f, 0x77, 0x5a, 0x65, 0x72, 0x6f)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.ShowZero)
		if err != nil {
			return
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Field) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [11]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "Zid"
	o = append(o, 0xa3, 0x5a, 0x69, 0x64)
	o = msgp.AppendInt64(o, z.Zid)
	// string "FieldGoName"
	o = append(o, 0xab, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x47, 0x6f, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.FieldGoName)
	if !empty[2] {
		// string "FieldTagName"
		o = append(o, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x61, 0x67, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.FieldTagName)
	}

	if !empty[3] {
		// string "FieldTypeStr"
		o = append(o, 0xac, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72)
		o = msgp.AppendString(o, z.FieldTypeStr)
	}

	if !empty[4] {
		// string "FieldCategory"
		o = append(o, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
		o = msgp.AppendUint64(o, uint64(z.FieldCategory))
	}

	if !empty[5] {
		// string "FieldPrimitive"
		o = append(o, 0xae, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65)
		o = msgp.AppendUint64(o, uint64(z.FieldPrimitive))
	}

	if !empty[6] {
		// string "FieldFullType"
		o = append(o, 0xad, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65)
		if z.FieldFullType == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.FieldFullType.MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	if !empty[7] {
		// string "OmitEmpty"
		o = append(o, 0xa9, 0x4f, 0x6d, 0x69, 0x74, 0x45, 0x6d, 0x70, 0x74, 0x79)
		o = msgp.AppendBool(o, z.OmitEmpty)
	}

	if !empty[8] {
		// string "Skip"
		o = append(o, 0xa4, 0x53, 0x6b, 0x69, 0x70)
		o = msgp.AppendBool(o, z.Skip)
	}

	if !empty[9] {
		// string "Deprecated"
		o = append(o, 0xaa, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64)
		o = msgp.AppendBool(o, z.Deprecated)
	}

	if !empty[10] {
		// string "ShowZero"
		o = append(o, 0xa8, 0x53, 0x68, 0x6f, 0x77, 0x5a, 0x65, 0x72, 0x6f)
		o = msgp.AppendBool(o, z.ShowZero)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Field) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Field) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields1zgvt = 11

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields1zgvt uint32
	if !nbs.AlwaysNil {
		totalEncodedFields1zgvt, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft1zgvt := totalEncodedFields1zgvt
	missingFieldsLeft1zgvt := maxFields1zgvt - totalEncodedFields1zgvt

	var nextMiss1zgvt int32 = -1
	var found1zgvt [maxFields1zgvt]bool
	var curField1zgvt string

doneWithStruct1zgvt:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft1zgvt > 0 || missingFieldsLeft1zgvt > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft1zgvt, missingFieldsLeft1zgvt, msgp.ShowFound(found1zgvt[:]), unmarshalMsgFieldOrder1zgvt)
		if encodedFieldsLeft1zgvt > 0 {
			encodedFieldsLeft1zgvt--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField1zgvt = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss1zgvt < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss1zgvt = 0
			}
			for nextMiss1zgvt < maxFields1zgvt && (found1zgvt[nextMiss1zgvt] || unmarshalMsgFieldSkip1zgvt[nextMiss1zgvt]) {
				nextMiss1zgvt++
			}
			if nextMiss1zgvt == maxFields1zgvt {
				// filled all the empty fields!
				break doneWithStruct1zgvt
			}
			missingFieldsLeft1zgvt--
			curField1zgvt = unmarshalMsgFieldOrder1zgvt[nextMiss1zgvt]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField1zgvt)
		switch curField1zgvt {
		// -- templateUnmarshalMsg ends here --

		case "Zid":
			found1zgvt[0] = true
			z.Zid, bts, err = nbs.ReadInt64Bytes(bts)

			if err != nil {
				return
			}
		case "FieldGoName":
			found1zgvt[1] = true
			z.FieldGoName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "FieldTagName":
			found1zgvt[2] = true
			z.FieldTagName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "FieldTypeStr":
			found1zgvt[3] = true
			z.FieldTypeStr, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "FieldCategory":
			found1zgvt[4] = true
			{
				var zlct uint64
				zlct, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.FieldCategory = Zkind(zlct)
			}
		case "FieldPrimitive":
			found1zgvt[5] = true
			{
				var zpro uint64
				zpro, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.FieldPrimitive = Zkind(zpro)
			}
		case "FieldFullType":
			found1zgvt[6] = true
			if nbs.AlwaysNil {
				if z.FieldFullType != nil {
					z.FieldFullType.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.FieldFullType {
						z.FieldFullType.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.FieldFullType == nil {
						z.FieldFullType = new(Ztype)
					}
					bts, err = z.FieldFullType.UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		case "OmitEmpty":
			found1zgvt[7] = true
			z.OmitEmpty, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case "Skip":
			found1zgvt[8] = true
			z.Skip, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case "Deprecated":
			found1zgvt[9] = true
			z.Deprecated, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		case "ShowZero":
			found1zgvt[10] = true
			z.ShowZero, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss1zgvt != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Field
var unmarshalMsgFieldOrder1zgvt = []string{"Zid", "FieldGoName", "FieldTagName", "FieldTypeStr", "FieldCategory", "FieldPrimitive", "FieldFullType", "OmitEmpty", "Skip", "Deprecated", "ShowZero"}

var unmarshalMsgFieldSkip1zgvt = []bool{false, false, false, false, false, false, false, false, false, false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Field) Msgsize() (s int) {
	s = 1 + 4 + msgp.Int64Size + 12 + msgp.StringPrefixSize + len(z.FieldGoName) + 13 + msgp.StringPrefixSize + len(z.FieldTagName) + 13 + msgp.StringPrefixSize + len(z.FieldTypeStr) + 14 + msgp.Uint64Size + 15 + msgp.Uint64Size + 14
	if z.FieldFullType == nil {
		s += msgp.NilSize
	} else {
		s += z.FieldFullType.Msgsize()
	}
	s += 10 + msgp.BoolSize + 5 + msgp.BoolSize + 11 + msgp.BoolSize + 9 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Schema) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields2zovp = 5

	// -- templateDecodeMsg starts here--
	var totalEncodedFields2zovp uint32
	totalEncodedFields2zovp, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft2zovp := totalEncodedFields2zovp
	missingFieldsLeft2zovp := maxFields2zovp - totalEncodedFields2zovp

	var nextMiss2zovp int32 = -1
	var found2zovp [maxFields2zovp]bool
	var curField2zovp string

doneWithStruct2zovp:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft2zovp > 0 || missingFieldsLeft2zovp > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft2zovp, missingFieldsLeft2zovp, msgp.ShowFound(found2zovp[:]), decodeMsgFieldOrder2zovp)
		if encodedFieldsLeft2zovp > 0 {
			encodedFieldsLeft2zovp--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField2zovp = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss2zovp < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss2zovp = 0
			}
			for nextMiss2zovp < maxFields2zovp && (found2zovp[nextMiss2zovp] || decodeMsgFieldSkip2zovp[nextMiss2zovp]) {
				nextMiss2zovp++
			}
			if nextMiss2zovp == maxFields2zovp {
				// filled all the empty fields!
				break doneWithStruct2zovp
			}
			missingFieldsLeft2zovp--
			curField2zovp = decodeMsgFieldOrder2zovp[nextMiss2zovp]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField2zovp)
		switch curField2zovp {
		// -- templateDecodeMsg ends here --

		case "SourcePath":
			found2zovp[0] = true
			z.SourcePath, err = dc.ReadString()
			if err != nil {
				return
			}
		case "SourcePackage":
			found2zovp[1] = true
			z.SourcePackage, err = dc.ReadString()
			if err != nil {
				return
			}
		case "ZebraSchemaId":
			found2zovp[2] = true
			z.ZebraSchemaId, err = dc.ReadInt64()
			if err != nil {
				return
			}
		case "Structs":
			found2zovp[3] = true
			var zawk uint32
			zawk, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			if z.Structs == nil && zawk > 0 {
				z.Structs = make(map[string]*Struct, zawk)
			} else if len(z.Structs) > 0 {
				for key, _ := range z.Structs {
					delete(z.Structs, key)
				}
			}
			for zawk > 0 {
				zawk--
				var zbif string
				var zszx *Struct
				zbif, err = dc.ReadString()
				if err != nil {
					return
				}
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					zszx = nil
				} else {
					if zszx == nil {
						zszx = new(Struct)
					}
					const maxFields3zbnr = 2

					// -- templateDecodeMsg starts here--
					var totalEncodedFields3zbnr uint32
					totalEncodedFields3zbnr, err = dc.ReadMapHeader()
					if err != nil {
						return
					}
					encodedFieldsLeft3zbnr := totalEncodedFields3zbnr
					missingFieldsLeft3zbnr := maxFields3zbnr - totalEncodedFields3zbnr

					var nextMiss3zbnr int32 = -1
					var found3zbnr [maxFields3zbnr]bool
					var curField3zbnr string

				doneWithStruct3zbnr:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft3zbnr > 0 || missingFieldsLeft3zbnr > 0 {
						//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft3zbnr, missingFieldsLeft3zbnr, msgp.ShowFound(found3zbnr[:]), decodeMsgFieldOrder3zbnr)
						if encodedFieldsLeft3zbnr > 0 {
							encodedFieldsLeft3zbnr--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								return
							}
							curField3zbnr = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss3zbnr < 0 {
								// tell the reader to only give us Nils
								// until further notice.
								dc.PushAlwaysNil()
								nextMiss3zbnr = 0
							}
							for nextMiss3zbnr < maxFields3zbnr && (found3zbnr[nextMiss3zbnr] || decodeMsgFieldSkip3zbnr[nextMiss3zbnr]) {
								nextMiss3zbnr++
							}
							if nextMiss3zbnr == maxFields3zbnr {
								// filled all the empty fields!
								break doneWithStruct3zbnr
							}
							missingFieldsLeft3zbnr--
							curField3zbnr = decodeMsgFieldOrder3zbnr[nextMiss3zbnr]
						}
						//fmt.Printf("switching on curField: '%v'\n", curField3zbnr)
						switch curField3zbnr {
						// -- templateDecodeMsg ends here --

						case "StructName":
							found3zbnr[0] = true
							zszx.StructName, err = dc.ReadString()
							if err != nil {
								return
							}
						case "Fields":
							found3zbnr[1] = true
							var znxb uint32
							znxb, err = dc.ReadArrayHeader()
							if err != nil {
								return
							}
							if cap(zszx.Fields) >= int(znxb) {
								zszx.Fields = (zszx.Fields)[:znxb]
							} else {
								zszx.Fields = make([]Field, znxb)
							}
							for zcut := range zszx.Fields {
								err = zszx.Fields[zcut].DecodeMsg(dc)
								if err != nil {
									return
								}
							}
						default:
							err = dc.Skip()
							if err != nil {
								return
							}
						}
					}
					if nextMiss3zbnr != -1 {
						dc.PopAlwaysNil()
					}

				}
				z.Structs[zbif] = zszx
			}
		case "Imports":
			found2zovp[4] = true
			var zham uint32
			zham, err = dc.ReadArrayHeader()
			if err != nil {
				return
			}
			if cap(z.Imports) >= int(zham) {
				z.Imports = (z.Imports)[:zham]
			} else {
				z.Imports = make([]string, zham)
			}
			for zxsf := range z.Imports {
				z.Imports[zxsf], err = dc.ReadString()
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss2zovp != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Schema
var decodeMsgFieldOrder2zovp = []string{"SourcePath", "SourcePackage", "ZebraSchemaId", "Structs", "Imports"}

var decodeMsgFieldSkip2zovp = []bool{false, false, false, false, false}

// fields of Struct
var decodeMsgFieldOrder3zbnr = []string{"StructName", "Fields"}

var decodeMsgFieldSkip3zbnr = []bool{false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Schema) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 5
	}
	var fieldsInUse uint32 = 5
	isempty[0] = (len(z.SourcePath) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.SourcePackage) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.ZebraSchemaId == 0) // number, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.Structs) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (len(z.Imports) == 0) // string, omitempty
	if isempty[4] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Schema) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zeqz [5]bool
	fieldsInUse_zaqw := z.fieldsNotEmpty(empty_zeqz[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zaqw)
	if err != nil {
		return err
	}

	if !empty_zeqz[0] {
		// write "SourcePath"
		err = en.Append(0xaa, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x74, 0x68)
		if err != nil {
			return err
		}
		err = en.WriteString(z.SourcePath)
		if err != nil {
			return
		}
	}

	if !empty_zeqz[1] {
		// write "SourcePackage"
		err = en.Append(0xad, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.SourcePackage)
		if err != nil {
			return
		}
	}

	if !empty_zeqz[2] {
		// write "ZebraSchemaId"
		err = en.Append(0xad, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x49, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteInt64(z.ZebraSchemaId)
		if err != nil {
			return
		}
	}

	if !empty_zeqz[3] {
		// write "Structs"
		err = en.Append(0xa7, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Structs)))
		if err != nil {
			return
		}
		for zbif, zszx := range z.Structs {
			err = en.WriteString(zbif)
			if err != nil {
				return
			}
			if zszx == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				// map header, size 2
				// write "StructName"
				err = en.Append(0x82, 0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65)
				if err != nil {
					return err
				}
				err = en.WriteString(zszx.StructName)
				if err != nil {
					return
				}
				// write "Fields"
				err = en.Append(0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73)
				if err != nil {
					return err
				}
				err = en.WriteArrayHeader(uint32(len(zszx.Fields)))
				if err != nil {
					return
				}
				for zcut := range zszx.Fields {
					err = zszx.Fields[zcut].EncodeMsg(en)
					if err != nil {
						return
					}
				}
			}
		}
	}

	if !empty_zeqz[4] {
		// write "Imports"
		err = en.Append(0xa7, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Imports)))
		if err != nil {
			return
		}
		for zxsf := range z.Imports {
			err = en.WriteString(z.Imports[zxsf])
			if err != nil {
				return
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Schema) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [5]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "SourcePath"
		o = append(o, 0xaa, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x74, 0x68)
		o = msgp.AppendString(o, z.SourcePath)
	}

	if !empty[1] {
		// string "SourcePackage"
		o = append(o, 0xad, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65)
		o = msgp.AppendString(o, z.SourcePackage)
	}

	if !empty[2] {
		// string "ZebraSchemaId"
		o = append(o, 0xad, 0x5a, 0x65, 0x62, 0x72, 0x61, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x49, 0x64)
		o = msgp.AppendInt64(o, z.ZebraSchemaId)
	}

	if !empty[3] {
		// string "Structs"
		o = append(o, 0xa7, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Structs)))
		for zbif, zszx := range z.Structs {
			o = msgp.AppendString(o, zbif)
			if zszx == nil {
				o = msgp.AppendNil(o)
			} else {
				// map header, size 2
				// string "StructName"
				o = append(o, 0x82, 0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65)
				o = msgp.AppendString(o, zszx.StructName)
				// string "Fields"
				o = append(o, 0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73)
				o = msgp.AppendArrayHeader(o, uint32(len(zszx.Fields)))
				for zcut := range zszx.Fields {
					o, err = zszx.Fields[zcut].MarshalMsg(o)
					if err != nil {
						return
					}
				}
			}
		}
	}

	if !empty[4] {
		// string "Imports"
		o = append(o, 0xa7, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Imports)))
		for zxsf := range z.Imports {
			o = msgp.AppendString(o, z.Imports[zxsf])
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Schema) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Schema) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields4zads = 5

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields4zads uint32
	if !nbs.AlwaysNil {
		totalEncodedFields4zads, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft4zads := totalEncodedFields4zads
	missingFieldsLeft4zads := maxFields4zads - totalEncodedFields4zads

	var nextMiss4zads int32 = -1
	var found4zads [maxFields4zads]bool
	var curField4zads string

doneWithStruct4zads:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft4zads > 0 || missingFieldsLeft4zads > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft4zads, missingFieldsLeft4zads, msgp.ShowFound(found4zads[:]), unmarshalMsgFieldOrder4zads)
		if encodedFieldsLeft4zads > 0 {
			encodedFieldsLeft4zads--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField4zads = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss4zads < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss4zads = 0
			}
			for nextMiss4zads < maxFields4zads && (found4zads[nextMiss4zads] || unmarshalMsgFieldSkip4zads[nextMiss4zads]) {
				nextMiss4zads++
			}
			if nextMiss4zads == maxFields4zads {
				// filled all the empty fields!
				break doneWithStruct4zads
			}
			missingFieldsLeft4zads--
			curField4zads = unmarshalMsgFieldOrder4zads[nextMiss4zads]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField4zads)
		switch curField4zads {
		// -- templateUnmarshalMsg ends here --

		case "SourcePath":
			found4zads[0] = true
			z.SourcePath, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "SourcePackage":
			found4zads[1] = true
			z.SourcePackage, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "ZebraSchemaId":
			found4zads[2] = true
			z.ZebraSchemaId, bts, err = nbs.ReadInt64Bytes(bts)

			if err != nil {
				return
			}
		case "Structs":
			found4zads[3] = true
			if nbs.AlwaysNil {
				if len(z.Structs) > 0 {
					for key, _ := range z.Structs {
						delete(z.Structs, key)
					}
				}

			} else {

				var zcpx uint32
				zcpx, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				if z.Structs == nil && zcpx > 0 {
					z.Structs = make(map[string]*Struct, zcpx)
				} else if len(z.Structs) > 0 {
					for key, _ := range z.Structs {
						delete(z.Structs, key)
					}
				}
				for zcpx > 0 {
					var zbif string
					var zszx *Struct
					zcpx--
					zbif, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						return
					}
					// default gPtr logic.
					if nbs.PeekNil(bts) && zszx == nil {
						// consume the nil
						bts, err = nbs.ReadNilBytes(bts)
						if err != nil {
							return
						}
					} else {
						// read as-if the wire has bytes, letting nbs take care of nils.

						if zszx == nil {
							zszx = new(Struct)
						}
						const maxFields5zpoe = 2

						// -- templateUnmarshalMsg starts here--
						var totalEncodedFields5zpoe uint32
						if !nbs.AlwaysNil {
							totalEncodedFields5zpoe, bts, err = nbs.ReadMapHeaderBytes(bts)
							if err != nil {
								return
							}
						}
						encodedFieldsLeft5zpoe := totalEncodedFields5zpoe
						missingFieldsLeft5zpoe := maxFields5zpoe - totalEncodedFields5zpoe

						var nextMiss5zpoe int32 = -1
						var found5zpoe [maxFields5zpoe]bool
						var curField5zpoe string

					doneWithStruct5zpoe:
						// First fill all the encoded fields, then
						// treat the remaining, missing fields, as Nil.
						for encodedFieldsLeft5zpoe > 0 || missingFieldsLeft5zpoe > 0 {
							//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft5zpoe, missingFieldsLeft5zpoe, msgp.ShowFound(found5zpoe[:]), unmarshalMsgFieldOrder5zpoe)
							if encodedFieldsLeft5zpoe > 0 {
								encodedFieldsLeft5zpoe--
								field, bts, err = nbs.ReadMapKeyZC(bts)
								if err != nil {
									return
								}
								curField5zpoe = msgp.UnsafeString(field)
							} else {
								//missing fields need handling
								if nextMiss5zpoe < 0 {
									// set bts to contain just mnil (0xc0)
									bts = nbs.PushAlwaysNil(bts)
									nextMiss5zpoe = 0
								}
								for nextMiss5zpoe < maxFields5zpoe && (found5zpoe[nextMiss5zpoe] || unmarshalMsgFieldSkip5zpoe[nextMiss5zpoe]) {
									nextMiss5zpoe++
								}
								if nextMiss5zpoe == maxFields5zpoe {
									// filled all the empty fields!
									break doneWithStruct5zpoe
								}
								missingFieldsLeft5zpoe--
								curField5zpoe = unmarshalMsgFieldOrder5zpoe[nextMiss5zpoe]
							}
							//fmt.Printf("switching on curField: '%v'\n", curField5zpoe)
							switch curField5zpoe {
							// -- templateUnmarshalMsg ends here --

							case "StructName":
								found5zpoe[0] = true
								zszx.StructName, bts, err = nbs.ReadStringBytes(bts)

								if err != nil {
									return
								}
							case "Fields":
								found5zpoe[1] = true
								if nbs.AlwaysNil {
									(zszx.Fields) = (zszx.Fields)[:0]
								} else {

									var zzjk uint32
									zzjk, bts, err = nbs.ReadArrayHeaderBytes(bts)
									if err != nil {
										return
									}
									if cap(zszx.Fields) >= int(zzjk) {
										zszx.Fields = (zszx.Fields)[:zzjk]
									} else {
										zszx.Fields = make([]Field, zzjk)
									}
									for zcut := range zszx.Fields {
										bts, err = zszx.Fields[zcut].UnmarshalMsg(bts)
										if err != nil {
											return
										}
										if err != nil {
											return
										}
									}
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									return
								}
							}
						}
						if nextMiss5zpoe != -1 {
							bts = nbs.PopAlwaysNil()
						}

					}
					z.Structs[zbif] = zszx
				}
			}
		case "Imports":
			found4zads[4] = true
			if nbs.AlwaysNil {
				(z.Imports) = (z.Imports)[:0]
			} else {

				var zizx uint32
				zizx, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.Imports) >= int(zizx) {
					z.Imports = (z.Imports)[:zizx]
				} else {
					z.Imports = make([]string, zizx)
				}
				for zxsf := range z.Imports {
					z.Imports[zxsf], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss4zads != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Schema
var unmarshalMsgFieldOrder4zads = []string{"SourcePath", "SourcePackage", "ZebraSchemaId", "Structs", "Imports"}

var unmarshalMsgFieldSkip4zads = []bool{false, false, false, false, false}

// fields of Struct
var unmarshalMsgFieldOrder5zpoe = []string{"StructName", "Fields"}

var unmarshalMsgFieldSkip5zpoe = []bool{false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Schema) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.SourcePath) + 14 + msgp.StringPrefixSize + len(z.SourcePackage) + 14 + msgp.Int64Size + 8 + msgp.MapHeaderSize
	if z.Structs != nil {
		for zbif, zszx := range z.Structs {
			_ = zszx
			_ = zbif
			s += msgp.StringPrefixSize + len(zbif)
			if zszx == nil {
				s += msgp.NilSize
			} else {
				s += 1 + 11 + msgp.StringPrefixSize + len(zszx.StructName) + 7 + msgp.ArrayHeaderSize
				for zcut := range zszx.Fields {
					s += zszx.Fields[zcut].Msgsize()
				}
			}
		}
	}
	s += 8 + msgp.ArrayHeaderSize
	for zxsf := range z.Imports {
		s += msgp.StringPrefixSize + len(z.Imports[zxsf])
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Struct) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields6zblc = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields6zblc uint32
	totalEncodedFields6zblc, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft6zblc := totalEncodedFields6zblc
	missingFieldsLeft6zblc := maxFields6zblc - totalEncodedFields6zblc

	var nextMiss6zblc int32 = -1
	var found6zblc [maxFields6zblc]bool
	var curField6zblc string

doneWithStruct6zblc:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft6zblc > 0 || missingFieldsLeft6zblc > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft6zblc, missingFieldsLeft6zblc, msgp.ShowFound(found6zblc[:]), decodeMsgFieldOrder6zblc)
		if encodedFieldsLeft6zblc > 0 {
			encodedFieldsLeft6zblc--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField6zblc = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss6zblc < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss6zblc = 0
			}
			for nextMiss6zblc < maxFields6zblc && (found6zblc[nextMiss6zblc] || decodeMsgFieldSkip6zblc[nextMiss6zblc]) {
				nextMiss6zblc++
			}
			if nextMiss6zblc == maxFields6zblc {
				// filled all the empty fields!
				break doneWithStruct6zblc
			}
			missingFieldsLeft6zblc--
			curField6zblc = decodeMsgFieldOrder6zblc[nextMiss6zblc]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField6zblc)
		switch curField6zblc {
		// -- templateDecodeMsg ends here --

		case "StructName":
			found6zblc[0] = true
			z.StructName, err = dc.ReadString()
			if err != nil {
				return
			}
		case "Fields":
			found6zblc[1] = true
			var zhja uint32
			zhja, err = dc.ReadArrayHeader()
			if err != nil {
				return
			}
			if cap(z.Fields) >= int(zhja) {
				z.Fields = (z.Fields)[:zhja]
			} else {
				z.Fields = make([]Field, zhja)
			}
			for zpip := range z.Fields {
				err = z.Fields[zpip].DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss6zblc != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Struct
var decodeMsgFieldOrder6zblc = []string{"StructName", "Fields"}

var decodeMsgFieldSkip6zblc = []bool{false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Struct) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 2
	}
	var fieldsInUse uint32 = 2
	isempty[0] = (len(z.StructName) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Fields) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Struct) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zdyn [2]bool
	fieldsInUse_zlph := z.fieldsNotEmpty(empty_zdyn[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zlph)
	if err != nil {
		return err
	}

	if !empty_zdyn[0] {
		// write "StructName"
		err = en.Append(0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.StructName)
		if err != nil {
			return
		}
	}

	if !empty_zdyn[1] {
		// write "Fields"
		err = en.Append(0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Fields)))
		if err != nil {
			return
		}
		for zpip := range z.Fields {
			err = z.Fields[zpip].EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Struct) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [2]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "StructName"
		o = append(o, 0xaa, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.StructName)
	}

	if !empty[1] {
		// string "Fields"
		o = append(o, 0xa6, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Fields)))
		for zpip := range z.Fields {
			o, err = z.Fields[zpip].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Struct) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Struct) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields7zxha = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields7zxha uint32
	if !nbs.AlwaysNil {
		totalEncodedFields7zxha, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft7zxha := totalEncodedFields7zxha
	missingFieldsLeft7zxha := maxFields7zxha - totalEncodedFields7zxha

	var nextMiss7zxha int32 = -1
	var found7zxha [maxFields7zxha]bool
	var curField7zxha string

doneWithStruct7zxha:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft7zxha > 0 || missingFieldsLeft7zxha > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft7zxha, missingFieldsLeft7zxha, msgp.ShowFound(found7zxha[:]), unmarshalMsgFieldOrder7zxha)
		if encodedFieldsLeft7zxha > 0 {
			encodedFieldsLeft7zxha--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField7zxha = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss7zxha < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss7zxha = 0
			}
			for nextMiss7zxha < maxFields7zxha && (found7zxha[nextMiss7zxha] || unmarshalMsgFieldSkip7zxha[nextMiss7zxha]) {
				nextMiss7zxha++
			}
			if nextMiss7zxha == maxFields7zxha {
				// filled all the empty fields!
				break doneWithStruct7zxha
			}
			missingFieldsLeft7zxha--
			curField7zxha = unmarshalMsgFieldOrder7zxha[nextMiss7zxha]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField7zxha)
		switch curField7zxha {
		// -- templateUnmarshalMsg ends here --

		case "StructName":
			found7zxha[0] = true
			z.StructName, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "Fields":
			found7zxha[1] = true
			if nbs.AlwaysNil {
				(z.Fields) = (z.Fields)[:0]
			} else {

				var zgyt uint32
				zgyt, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.Fields) >= int(zgyt) {
					z.Fields = (z.Fields)[:zgyt]
				} else {
					z.Fields = make([]Field, zgyt)
				}
				for zpip := range z.Fields {
					bts, err = z.Fields[zpip].UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss7zxha != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Struct
var unmarshalMsgFieldOrder7zxha = []string{"StructName", "Fields"}

var unmarshalMsgFieldSkip7zxha = []bool{false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Struct) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.StructName) + 7 + msgp.ArrayHeaderSize
	for zpip := range z.Fields {
		s += z.Fields[zpip].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Zkind) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zswg uint64
		zswg, err = dc.ReadUint64()
		(*z) = Zkind(zswg)
	}
	if err != nil {
		return
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z Zkind) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteUint64(uint64(z))
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Zkind) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Zkind) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Zkind) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zpjf uint64
		zpjf, bts, err = nbs.ReadUint64Bytes(bts)

		if err != nil {
			return
		}
		(*z) = Zkind(zpjf)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Zkind) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Ztype) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields8zeeq = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields8zeeq uint32
	totalEncodedFields8zeeq, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft8zeeq := totalEncodedFields8zeeq
	missingFieldsLeft8zeeq := maxFields8zeeq - totalEncodedFields8zeeq

	var nextMiss8zeeq int32 = -1
	var found8zeeq [maxFields8zeeq]bool
	var curField8zeeq string

doneWithStruct8zeeq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft8zeeq > 0 || missingFieldsLeft8zeeq > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft8zeeq, missingFieldsLeft8zeeq, msgp.ShowFound(found8zeeq[:]), decodeMsgFieldOrder8zeeq)
		if encodedFieldsLeft8zeeq > 0 {
			encodedFieldsLeft8zeeq--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField8zeeq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss8zeeq < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss8zeeq = 0
			}
			for nextMiss8zeeq < maxFields8zeeq && (found8zeeq[nextMiss8zeeq] || decodeMsgFieldSkip8zeeq[nextMiss8zeeq]) {
				nextMiss8zeeq++
			}
			if nextMiss8zeeq == maxFields8zeeq {
				// filled all the empty fields!
				break doneWithStruct8zeeq
			}
			missingFieldsLeft8zeeq--
			curField8zeeq = decodeMsgFieldOrder8zeeq[nextMiss8zeeq]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField8zeeq)
		switch curField8zeeq {
		// -- templateDecodeMsg ends here --

		case "Kind":
			found8zeeq[0] = true
			{
				var zhpq uint64
				zhpq, err = dc.ReadUint64()
				z.Kind = Zkind(zhpq)
			}
			if err != nil {
				return
			}
		case "Str":
			found8zeeq[1] = true
			z.Str, err = dc.ReadString()
			if err != nil {
				return
			}
		case "Domain":
			found8zeeq[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Domain != nil {
					dc.PushAlwaysNil()
					err = z.Domain.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Domain == nil {
					z.Domain = new(Ztype)
				}
				err = z.Domain.DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		case "Range":
			found8zeeq[3] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Range != nil {
					dc.PushAlwaysNil()
					err = z.Range.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Range == nil {
					z.Range = new(Ztype)
				}
				err = z.Range.DecodeMsg(dc)
				if err != nil {
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	if nextMiss8zeeq != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Ztype
var decodeMsgFieldOrder8zeeq = []string{"Kind", "Str", "Domain", "Range"}

var decodeMsgFieldSkip8zeeq = []bool{false, false, false, false}

// fieldsNotEmpty supports omitempty tags
func (z *Ztype) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 4
	}
	var fieldsInUse uint32 = 4
	isempty[1] = (len(z.Str) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Domain == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (z.Range == nil) // pointer, omitempty
	if isempty[3] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Ztype) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// honor the omitempty tags
	var empty_zkff [4]bool
	fieldsInUse_zytn := z.fieldsNotEmpty(empty_zkff[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zytn)
	if err != nil {
		return err
	}

	// write "Kind"
	err = en.Append(0xa4, 0x4b, 0x69, 0x6e, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteUint64(uint64(z.Kind))
	if err != nil {
		return
	}
	if !empty_zkff[1] {
		// write "Str"
		err = en.Append(0xa3, 0x53, 0x74, 0x72)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Str)
		if err != nil {
			return
		}
	}

	if !empty_zkff[2] {
		// write "Domain"
		err = en.Append(0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
		if err != nil {
			return err
		}
		if z.Domain == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Domain.EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	if !empty_zkff[3] {
		// write "Range"
		err = en.Append(0xa5, 0x52, 0x61, 0x6e, 0x67, 0x65)
		if err != nil {
			return err
		}
		if z.Range == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Range.EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Ztype) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [4]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "Kind"
	o = append(o, 0xa4, 0x4b, 0x69, 0x6e, 0x64)
	o = msgp.AppendUint64(o, uint64(z.Kind))
	if !empty[1] {
		// string "Str"
		o = append(o, 0xa3, 0x53, 0x74, 0x72)
		o = msgp.AppendString(o, z.Str)
	}

	if !empty[2] {
		// string "Domain"
		o = append(o, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
		if z.Domain == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Domain.MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	if !empty[3] {
		// string "Range"
		o = append(o, 0xa5, 0x52, 0x61, 0x6e, 0x67, 0x65)
		if z.Range == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Range.MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Ztype) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Ztype) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields9zbil = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields9zbil uint32
	if !nbs.AlwaysNil {
		totalEncodedFields9zbil, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
	}
	encodedFieldsLeft9zbil := totalEncodedFields9zbil
	missingFieldsLeft9zbil := maxFields9zbil - totalEncodedFields9zbil

	var nextMiss9zbil int32 = -1
	var found9zbil [maxFields9zbil]bool
	var curField9zbil string

doneWithStruct9zbil:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft9zbil > 0 || missingFieldsLeft9zbil > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft9zbil, missingFieldsLeft9zbil, msgp.ShowFound(found9zbil[:]), unmarshalMsgFieldOrder9zbil)
		if encodedFieldsLeft9zbil > 0 {
			encodedFieldsLeft9zbil--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			curField9zbil = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss9zbil < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss9zbil = 0
			}
			for nextMiss9zbil < maxFields9zbil && (found9zbil[nextMiss9zbil] || unmarshalMsgFieldSkip9zbil[nextMiss9zbil]) {
				nextMiss9zbil++
			}
			if nextMiss9zbil == maxFields9zbil {
				// filled all the empty fields!
				break doneWithStruct9zbil
			}
			missingFieldsLeft9zbil--
			curField9zbil = unmarshalMsgFieldOrder9zbil[nextMiss9zbil]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField9zbil)
		switch curField9zbil {
		// -- templateUnmarshalMsg ends here --

		case "Kind":
			found9zbil[0] = true
			{
				var zlre uint64
				zlre, bts, err = nbs.ReadUint64Bytes(bts)

				if err != nil {
					return
				}
				z.Kind = Zkind(zlre)
			}
		case "Str":
			found9zbil[1] = true
			z.Str, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				return
			}
		case "Domain":
			found9zbil[2] = true
			if nbs.AlwaysNil {
				if z.Domain != nil {
					z.Domain.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Domain {
						z.Domain.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Domain == nil {
						z.Domain = new(Ztype)
					}
					bts, err = z.Domain.UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		case "Range":
			found9zbil[3] = true
			if nbs.AlwaysNil {
				if z.Range != nil {
					z.Range.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Range {
						z.Range.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Range == nil {
						z.Range = new(Ztype)
					}
					bts, err = z.Range.UnmarshalMsg(bts)
					if err != nil {
						return
					}
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	if nextMiss9zbil != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// fields of Ztype
var unmarshalMsgFieldOrder9zbil = []string{"Kind", "Str", "Domain", "Range"}

var unmarshalMsgFieldSkip9zbil = []bool{false, false, false, false}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ztype) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 4 + msgp.StringPrefixSize + len(z.Str) + 7
	if z.Domain == nil {
		s += msgp.NilSize
	} else {
		s += z.Domain.Msgsize()
	}
	s += 6
	if z.Range == nil {
		s += msgp.NilSize
	} else {
		s += z.Range.Msgsize()
	}
	return
}
